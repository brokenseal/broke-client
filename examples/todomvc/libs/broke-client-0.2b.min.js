/*
 * Broke-client - Davide Callegari - http://www.brokenseal.it/
 * 
 * Inspired by the Django Web Framework - http://www.djangoproject.com/
 * A lot of inspirement/copy from other Javascript Libraries like:
 *  - jQuery - http://jquery.com/
 *  - JavascriptMVC - http://javascriptmvc.com/
 * 
 * Licensed under MIT.
 * 
 */
var broke= {};

;(function(__global__, undefined){
    var
        extend= function() {
            var
                name,
                target = arguments[0] || {},
                i = 1,
                length = arguments.length,
                deep = false,
                options,
                src,
                copy
            ;

            if(arguments.length > 2) {
                broke.extend.apply(broke, arguments.slice(1));
            }
            // copy reference to target object
            // Handle a deep copy situation
            if ( typeof target === "boolean" ) {
                deep = target;
                target = arguments[1] || {};
                // skip the boolean and the target
                i = 2;
            }
            // Handle case when target is a string or something (possible in deep copy)
            if ( typeof target !== "object" && !(target instanceof Function)) {
                target = {};
            }
            // extend broke itself if only one argument is passed
            if ( length == i ) {
                target = this;
                --i;
            }
            while(i < length) {
                // Only deal with non-null/undefined values
                if ( (options = arguments[ i ]) !== null ) {
                    // Extend the base object
                    for ( name in options ) {
                        if(options.hasOwnProperty(name)) {
                            src = target[ name ];
                            copy = options[ name ];

                            // Prevent never-ending loop
                            if ( target === copy ) {
                                continue;
                            }
                            // Recurse if we're merging object values
                            if ( deep && copy && typeof copy === "object" && !copy.nodeType ) {
                                target[ name ]= broke.extend( deep, src || ( copy.length !== null ? [ ] : { } ), copy );
                            }

                            // Don't bring in undefined values
                            else if ( copy !== undefined ) {
                                target[ name ] = copy;
                            }
                        }
                    }
                }

                i++;
            }
            // Return the modified object
            return target;
        }
        ,bindEvents= function(){
            var
                callback
                ,oldHash
                ,settings= broke.conf.settings
            ;
            
            /******************************** EVENTS BINDING ********************************/
            // elements binding
            if(settings.EVENT_TRIGGERING_METHOD == 'elements'){
                // --------- on elements ---------
                broke.bindEvents();
            
            // hash change binding
            } else if(settings.EVENT_TRIGGERING_METHOD == 'hashchange'){
                
                // if it does not exist, let's create it
                if(!('onhashchange' in window)){
                    oldHash= location.hash;
                    
                    setInterval(function(){
                        if(location.hash !== oldHash) {
                            oldHash= location.hash;

                            broke.DOM.e.trigger(window, 'hashchange');
                        }
                    }, settings.HASHCHANGE_INTERVAL);
                }
                
                // bind on hash change
                window.onhashchange= function(e){
                    broke.events.request({
                        event: e
                        ,url: location.hash.split('#')[1]
                    });
                };
            }
        }
        ,initProject= function(){
            var
                settings= broke.conf.settings
            ;
                
            // init installed apps' models
            settings.INSTALLED_APPS= builtins.map(settings.INSTALLED_APPS, function(){
                var
                    app= this
                ;
                
                if(builtins.typeOf(app) == "string") {
                    app= builtins.getattr(this);
                }
                
                if(!app) {
                    return null;
                }
                
                // init app's models
                builtins.forEach(app.models, function(){
                    var
                        tableName
                        ,defaultDbEngine
                    ;
                    
                    if(this.isUsable === false) {
                        return;
                    }
                    
                    defaultDbEngine= builtins.getattr(broke.conf.settings.DATABASES['default'].ENGINE);
                    defaultDbEngine.initTableForModel(this);
                    
                    // is this still useful?
                    //if(settings.ENABLE_FETCH_REMOTE_DATA && this.autoInit) {
                        // init the local storage data
                        //broke.initStorage(this);
                    //}
                    
                    broke.db.models.addContentType(this.appLabel, this.__name__.toLowerCase(), this);
                });

                return app;
            });
            
            return settings;
        }
    ;

    extend(broke, {
        /**************************** VERSION ********************************/
        VERSION: "0.2b"
        
        /************************ SETTINGS OBJECT ****************************/
        ,BROKE_SETTINGS_OBJECT: null    // it points to the registered project's settings
                                        // equivalent of Django's DJANGO_SETTINGS_MODULE
        
        /****************************** INIT *********************************/
        ,init: function(settingsObject, callback){
            var
                settings= broke.conf.settings
                ,currentUrl= location.hash.split('#')[1] || ''
            ;
            
            if(broke.events.isReady()) {
                // already initialized
                broke.log('Broke has already been initialized! Fail silently...');
                return;
            }
            
            if(!broke.BROKE_SETTINGS_OBJECT && !settingsObject) {
                // no settings object defined, fail out loud
                broke.log(gettext.gettext('Settings object not defined!'));
                
                return;
            } else if(!broke.BROKE_SETTINGS_OBJECT && settingsObject) {

                if(builtins.typeOf(settingsObject) == "string") {
                    settingsObject= builtins.getattr(settingsObject);
                }
                
                extend(settings, settingsObject);
            } else {
                extend(settings, builtins.getattr(broke.BROKE_SETTINGS_OBJECT));
            }
            
            // init project
            initProject();
            
            //if(settings.USE_I18N) {
                // determine the language
                //_setLanguage();
                
                // get language files
                //_getLanguageFiles();
            //}

            // bind events
            bindEvents();

            if(builtins.typeOf(callback) == "function") {
                callback();
            }
            
            // cache init
            //broke.core.cache.cache= broke.core.cache.getCache(settings.CACHE_BACKEND);
            
            // on broke init, request the current hash value, even if it's an empty string
            broke.events.request(currentUrl);

            broke.events.ready();
        }
        ,extend: extend
        ,log: function(debugString, doNotAppendDate){
            if(broke.conf.settings.DEBUG && 'console' in window) {
                if(!doNotAppendDate) {
                    var now= new Date();
                    now= builtins.interpolate('%s:%s:%s:%s', [now.getHours(), now.getMinutes(), now.getSeconds(), now.getMilliseconds()]);
                    debugString= builtins.interpolate('[%s] %s', [now, debugString]);
                }
                
                console.debug(debugString);
            }
        }
        ,bindEvents: function(context, applyToContext){
            var
                settings= broke.conf.settings
                ,callback= function(e){
                    var
                        tag= this.tagName.toLowerCase()
                        ,urlChangingElement= settings.URL_CHANGING_ELEMENTS[tag]
                        ,preventDefault= urlChangingElement.preventDefault !== undefined ? urlChangingElement.preventDefault : settings.PREVENT_DEFAULT
                        ,urlAttribute= urlChangingElement.urlAttribute
                        ,url= broke.DOM.attr(this, urlAttribute)
                        ,type= e.target.tagName.toLowerCase() == "form" ? 'POST' : 'GET'
                    ;

                    if(url !== undefined && url.indexOf('#') >= 0) {
                        if(preventDefault) {
                            e.preventDefault();
                        }

                        broke.events.request({
                            event: e,
                            url: url.split('#')[1],
                            completeUrl: url,
                            type: type
                        });
                    }
                }
            ;
            context= context || document;

            // collect all the url changing elements
            builtins.forEach(settings.URL_CHANGING_ELEMENTS, function(key){
                var
                    domQueryResult
                ;
                
                if(applyToContext === true) {
                    domQueryResult= context;
                } else {
                    domQueryResult= broke.DOM.q(key, context);
                }

                // bind only support, need to make delegate available and change settings
                broke.DOM.e.addListener(domQueryResult, this.events.join(','), callback);
            });
        }
        ,DOM: {}
        ,conf: {}
        ,core: {}
        ,db: {}
    });
})(this);;(function(__global__, undefined){
    var
        querySelectorCache= {}
    ;
    
    broke.extend(broke.DOM, {
        querySelector: function(query, context){
            var
                queryResult
            ;

            context= context || document;
            queryResult= jQuery(query, jQuery(context));
            
            return queryResult;
        }
        ,clearCache: function(){
            querySelectorCache= {};

            return;
        }
        ,val: function(object, value){

            if(value !== undefined) {
                jQuery(object).val(value);

                return object;
            }

            return jQuery(object).val();
        }
        ,attr: function(object, attributeName, value){
            if(value !== undefined) {
                jQuery(object).attr(attributeName, value);

                return value;
            }
            
            return jQuery(object).attr(attributeName);
        }
        ,removeAttr: function(object, attributeName){
            jQuery(object).removeAttr(attributeName);
            
            return object;
        }
        ,html: function(element, htmlString){
            jQuery(element).html(htmlString);
            
            return element;
        }
        ,text: function(element, text){
            jQuery(element).text(text);
            
            return element;
        }
        ,manipulation: {
            append: function(elementToAppend, parentElement){
                jQuery(parentElement).append(elementToAppend);

                return elementToAppend;
            }
            ,clone: function(object){
                return jQuery(object).clone(false)[0];
            }
            ,create: function(elementName, properties){
                return jQuery('<' + elementName + ' />', properties);
            }
            ,createFromString: function(htmlString){
                var
                    html= jQuery(htmlString)
                ;
                
                return html.length > 1 ? html.get() : html.get(0);
            }
            ,filter: function(elements, filterExpression){
                return jQuery(elements).filter(filterExpression);
            }
            ,replace: function(firstElement, secondElement){
                jQuery(firstElement).replaceWith(secondElement);

                return firstElement;
            }
        }
        // events naming follow jquery convention, stripping down the initial 'on' and keeping everything lower case
        // e.g. onClick -> click, onSubmit -> submit
        ,events: {
            addListener: function(object, eventName, callback){
                
                if(builtins.isArray(object)) {

                    builtins.forEach(object, function(){
                        jQuery(this).bind(eventName, callback);
                    });
                    
                } else {
                    jQuery(object).bind(eventName, callback);
                }

                return object;
            }
            ,removeListener: function(object, eventName, callback){
                jQuery(object).unbind(eventName, callback);

                return object;
            }
            ,trigger: function(object, eventName, args){
                jQuery(object).trigger(eventName, args);

                return object;
            }
            ,delegate: function(object, eventName){
                
            }
        }
    });

    // shortcuts
    broke.DOM.q= broke.DOM.querySelector;
    broke.DOM.m= broke.DOM.manipulation;
    broke.DOM.e= broke.DOM.events;
})(this);;(function(undefined){
    broke.conf.settings= {
        AJAX: {
            dataType: 'json' // ajax data type which returns from the server
            ,async: false
            ,cache: false
        }
        ,API_BASE_URL: '/api/'

        ,BASE_URL: '/broke'

        // cache system
        // broke implements only a local storage cache backend, for now
        ,CACHE_BACKEND: 'localStorage://'
        ,CACHE_MIDDLEWARE_SECONDS: 600
        ,CACHE_MIDDLEWARE_KEY_PREFIX: ''

        ,DATABASES: {
            'default': {
                NAME: ''
                ,ENGINE: 'broke.db.engines.LocalEngine'
                ,USER: ''
                ,PASSWORD: ''
            }
            ,'remote': {
                NAME: ''
                ,ENGINE: 'broke.db.engines.RemoteEngine'
                ,USER: ''
                ,PASSWORD: ''
                ,BASE_URL: '/api/'
            }
        }
        ,DATABASE_ROUTERS: ['broke.db.routers.DefaultRouter']

        ,DISALLOWED_USER_AGENTS: []

        ,DEBUG: false
        ,CONTEXT_PROCESSORS: []
        
        ,DATE_FORMAT: 'dd-mm-yy'
        ,ENABLE_FETCH_REMOTE_DATA: false
        ,EVENT_BINDING: 'live'          // bind|live
                                        // it should always be set to 'live' but
                                        // at the current stage jQuery's live
                                        // method does not alwasy work properly

        // 'EVENT_TRIGGERING_METHOD' determines the way to trigger the
        // broke.events.request event
        // WARNING: hashChange will work with an interval of 150ms on old browsers
        // on more recent browsers will make use of the 'onhashchange' event
        // which, by the time of the writing, it is only available on Firefox 3.6 and IE8
        // as for the 'elements' method please refer to the documentation under the
        // 'events' topic
        // choices are: elements, hashchange
        ,EVENT_TRIGGERING_METHOD: 'hashchange'

        ,FILE_SYSTEM: {
            SIZE: 5 * 1024 // 5 Kb default file system size
            ,PERSISTENT: true
            ,HOME_DIR: "/"
        }

        ,FORM: null                        // default operation form

        ,GET_LATEST_BY: 'pk'            // defines what field models' manager method
                                        // getLatest will look at

        ,HANDLER_404: 'broke.views.defaults.pageNotFound'

        ,HASHCHANGE_INTERVAL: 150        // interval in milliseconds for the
                                        // hashchange method to check for a changed
                                        // url
                                        // it's effective only if you've selected
                                        // 'eventTriggeringMethod' as 'hashchange'
                                        // and your browser does not support
                                        // the 'onhashchange' event

        ,HIDE_HASH: false                // whether you want the hash to be hidden
                                        // from the main url
                                        // careful: it will prevent any default action
                                        // from the browser from your event
                                        // equivalent to 'event.preventDefault();'

        ,JSON_URLS: null

        // locale specific settings
        ,LOCALE_PATHS: []
        ,LANGUAGE_CODE: 'en'
        ,LANGUAGES: {
            'en': 'English'
            ,'it': 'Italian'
        }
        ,LANGUAGE_COOKIE_NAME: 'broke_language'

        ,MIDDLEWARE_CLASSES: [
            'broke.middleware.common.CommonMiddleware'
        ]

        ,PREVENT_DEFAULT: false                // whether you want the broke.response to
                                            // prevent default action from the browser

        ,PRELOAD_REMOTE_TEMPLATES: false    // wether you want Broke to preload your templates
                                            // remotely
                                            // if set to true, Broke will attempt to download
                                            // your templates from a remote location
                                            // based on the basePath of your app
                                            // e.g.: if an app's baseDir is '/myProject/apps/blog'
                                            // and your app has a 'templates' object looks like
                                            // { 'entry-view.html': '' }, then Broke will try to
                                            // download '/myProject/apps/blog/templates/entry-view.html'

        ,QUERY_TYPE: 'local'            // local|remote
                                        // wether you want your query to hit a local database,
                                        // populated with previously fetched data,
                                        // or query the remote database
        ,RETURN: location.href        // form return url

        ,ROOT_URLCONF: null                // a string representing the object's configuration

        ,STOP_PROPAGATION: false        // whether you want the broke.response to
                                        // prevent event propagation

        ,SAVE: {
            async: false                // ajax or sjax?
            ,cache: false                // ajax cache
            ,commit: true                // if you want to prevent the object to
                                        // be saved right away, you should set this
                                        // to false and then explicitly call the
                                        // save method on the object with commit= true
                                        // e.g.: entry.save({commit: true})
                                        // if you actually want to save it on the server
        }
        ,TEMPLATE_STRING_IF_INVALID: ''
        ,TEMPLATE_PATHS: []
        ,TEMPLATE_LOADERS: [
            'broke.template.loaders.apps'
        ]

        // list of elements that trigger the
        // broke.events.request event, setting the url
        // WARNING: will only work if 'eventTriggeringMethod' is set to 'elements'
        ,URL_CHANGING_ELEMENTS: {
            'a': {
                events: ['click'],      // events
                urlAttribute: 'href'    // attribute holding the url
            }
            ,'form': {
                events: ['submit'],
                urlAttribute: 'action',
                preventDefault: true
            }
        }
        ,USE_AJAX: true                 // would you like to use ajax?
                                        // if false, it will create a form and
                                        // send your data through that form
                                        // WARNING: not ready yet!

        ,USE_I18N: false
        ,USE_NAMED_URLS: false
    };
})();(function(context, undefined){
    broke.conf.urls= {
        defaults: {
            patterns: function(prefix) {
                var
                    args= Array.prototype.slice.call(arguments)
                ;

                return builtins.map(args.slice(1), function(){
                    if(typeof this[1] == "string") {
                        this[1]= builtins.getattr(prefix + "." + this[1]);
                    }
                    return this;
                });
            }
            ,include: function(urlObject){
                if(typeof urlObject == "string") {
                    return builtins.getattr(urlObject);
                }
                return urlObject;
            }
            ,parseQueryString: function(queryString){
                var
                    result= {}
                ;

                if(!queryString) {
                    return {};
                }

                queryString= queryString.split('&');

                builtins.forEach(queryString, function(){
                    var tmp= this.split('=');
                    result[tmp[0]]= tmp[1];
                });

                return result;
            }
            ,parsePath: function(path){
                if(!path) {
                    return [];
                }

                return path.split('/').slice(1);
            }
        }
    };
})(this);broke.contextProcessors= {
    debug: function(request){
        return {
            'debug': broke.conf.settings.DEBUG
        };
    },
    i18n: function(request){
        return {
            'languageCode': broke.conf.settings.LANGUAGE_CODE,
            'languages': keys(broke.conf.settings.LANGUAGES)
        };
    }
};;(function(__global__, undefined){
    var
        isReady= false
        ,requestEventName= 'broke.request'
        ,responseEventName= 'broke.response'
        ,events= broke.DOM.events
        ,settings= broke.conf.settings

        // utility functions
        ,fireCallbacks= function(callbacks, args){
            builtins.forEach(callbacks, function(){
                this.apply(__global__, args);
            });
        }
    ;
    
    broke.events= {
        isReady: function(){
            return isReady;
        }
        // used for internal purpose only
        ,ready: function(){
            events.trigger(window, 'broke.ready');
            isReady= true;
            
            // make sure no one else will fires this
            delete broke.events.ready;
        }
        ,onReady: function(fn) {
            if(isReady) {
                fn();
            }
            
            events.addListener(window, 'broke.ready', fn);
        }
        ,unBindOnReady: function(fn){
            if(fn === undefined) {
                events.removeListener(window, 'broke.ready');
                return;
            }
            
            events.removeListener(window, 'broke.ready', fn);
        }
        ,preSave: function(klass, fn){
            var
                eventName= 'broke.' + klass.__name__.toLowerCase() + '.pre_save'
            ;

            events.addListener(window, eventName, fn);
        }
        ,postSave: function(klass, fn){
            var
                eventName= 'broke.' + klass.__name__.toLowerCase() + '.post_save'
            ;
            
            events.addListener(window, eventName, fn);
        }
        ,bindToRequest: function(fn){
            events.addListener(window, requestEventName, fn);
        }
        ,bindToResponse: function(fn){
            events.addListener(window, responseEventName, fn);
        }
        ,request: function(args, extraArgs){
            var
                req= {}
            ;

            if(builtins.typeOf(args) == 'string') {
                // first case: broke.events.request('/entry/view/1/');
                req.url= args;
            } else {
                // second case: broke.events.request({
                //     url: '/entry/view/1/',
                //     fromReload: true
                // });
                req= args;
            }

            events.trigger(window, requestEventName, [req, extraArgs]);
        }
        ,response: function(){
            events.trigger(window, responseEventName, arguments);
        }

        // some class declarations
        ,Deferred: null
        ,When: null
    };

    // mime jquery deferred api (CommonJS Promises/A design)
    Class.create({
        __name__: "broke.events.Deferred"
        
        // should make these attributes private or at least very hard to access
        ,_resolved: false
        ,_rejected: false
        ,_onSuccessCallbacks: []
        ,_onErrorCallbacks: []
        ,_onCompleteCallbacks: []
        ,_completedWithArgs: null

        ,then: function(onSuccessCallback, onErrorCallback){

            if(this.isResolved()) {
                fireCallbacks(onSuccessCallback, this._completedWithArgs);
            } else if(this.isRejected()){
                fireCallbacks(onErrorCallback, this._completedWithArgs);
            }
            
            this._onSuccessCallbacks.push(onSuccessCallback);
            this._onErrorCallbacks.push(onErrorCallback);
            
            return this;
        }
        ,resolve: function(){
            if(this.isResolved()) {
                // refuse to resolve an already resolved deferred
                return this;
            }

            fireCallbacks(this._onSuccessCallbacks, arguments);
            fireCallbacks(this._onCompleteCallbacks, arguments);

            this._completedWithArgs= arguments;

            return this;
        }
        ,reject: function(){
            if(this.isRejected()) {
                // refuse to reject an already rejected deferred
                return this;
            }

            fireCallbacks(this._onErrorCallbacks, arguments);
            fireCallbacks(this._onCompleteCallbacks, arguments);
            
            this._completedWithArgs= arguments;

            return this;
        }
        ,isResolved: function(){
            return this._rejected;
        }
        ,isRejected: function(){
            return this._resolved;
        }
        ,always: function(){
            if(this.isResolved() || this.isRejected()) {
                fireCallbacks(arguments, this._completedWithArgs);
            }
            
            this._onCompleteCallbacks= this._onCompleteCallbacks.concat(arguments);
            
            return this;
        }
        
        ,done: function(){
            if(this.isResolved()) {
                fireCallbacks(arguments, this._completedWithArgs);
            }

            this._onSuccessCallbacks= this._onSuccessCallbacks.concat(arguments);

            return this;
        }
        ,fail: function(){
            if(this.isRejected()) {
                fireCallbacks(arguments, this._completedWithArgs);
            }

            this._onErrorCallbacks= this._onErrorCallbacks.concat(arguments);

            return this;
        }
    });
    
    // Request event handling
    broke.events.bindToRequest(function(e, request, extraArgs, responseCallback){
        var
            response= {}
            ,view= null
            ,callback
            ,args= null
            ,urlMatchResult= []
            ,partialUrl
            ,target
            ,parseQueryString= broke.urlResolvers.parseQueryString
            ,queryString= {}
            ,resolve= broke.urlResolvers.resolve
        ;

        extraArgs= extraArgs || [];

        request= broke.extend({
            completeUrl: location.href,
            method: 'GET',
            fromReload: false,
            statusCode: 200,
            META: {}
        }, request);

        if(request.url === undefined) {
            return;
        }

        // set GET/POST/REQUEST
        partialUrl= request.url.split('?');
        if(partialUrl.length > 1) {
            request.url= partialUrl[0];
            queryString= parseQueryString(partialUrl[1]);

            request.GET= queryString;
        } else if(request.hasOwnProperty('event')
                    && request.event.target
                    && request.event.target.tagName
                    && request.event.target.tagName.toLowerCase() === "form"){
            
            builtins.forEach(broke.DOM.q('input,select,textarea', request.event.target), function(){
                try {
                    queryString[broke.DOM.attr(this, 'name')]= broke.DOM.val(this);
                } catch(e){}
            });

            request.POST= queryString;
        }
        request.REQUEST= queryString;

        // set META
        request.META= {
            HTTP_REFERER: location.hash.split('#')[1] || ''
        };
        
        // middleware fetching
        builtins.forEach(broke.conf.settings.MIDDLEWARE_CLASSES, function(){
            var
                middleware= builtins.getattr(this, __global__, {})
            ;

            if(middleware.processRequest !== undefined) {
                middleware.processRequest.apply(this, [request].concat(extraArgs));
            }
        });

        // url dispatcher
        try {
            urlMatchResult= resolve(request.url);
        } catch(error) {
            if(error.name == "NotFound") {
                //builtins.getattr(broke.conf.settings.HANDLER_404)(request);
                broke.events.response(response);
                return;

            } else {
                throw error;
            }
        }

        if(urlMatchResult) {
            view= urlMatchResult[0];
            args= urlMatchResult[1];

            if(extraArgs) {
                args= args.concat(extraArgs);
            }

            // put the request object as the first argument
            args.unshift(request);

            // create the callback function for the response to be taken
            callback= function(response){
                response= broke.extend(request, response);
                broke.events.response(response, extraArgs, responseCallback);
            };

            // put the callback as the last argument
            args.push(callback);

            view.apply(this, args);
        }
    });
    
    // Response event handling
    broke.events.bindToResponse(function(e, response, extraArgs, responseCallback){

        extraArgs= extraArgs || [];

        // apply additional properties
        builtins.forEach(response.additionalProperties, function(key){
            response.element[key]= this;
        });

        // apply callback
        if(builtins.typeOf(response.callback) == 'function') {
            response.callback.apply(response.element);
        }

        // --------- middleware fetching in reverse order ---------
        builtins.forEach(broke.conf.settings.MIDDLEWARE_CLASSES.reverse(), function(){
            var
                middleware= builtins.getattr(this, __global__, {})
            ;

            if(middleware.processResponse !== undefined) {
                middleware.processResponse.apply(this, [response].concat(extraArgs));
            }
        });
    });
})(this);;(function(undefined){
    
    broke.exceptions= {
        NotFound: function(message){
            return {
                name: "NotFound",
                message: message
            };
        }
        ,NotImplementedError: function(message){
            return {
                name: "NotImplementedError",
                message: message
            };
        }
        ,FieldError: function(message){
            return {
                name: "FieldError",
                message: message
            };
        }
        ,NoReverseMatch: function(message){
            return {
                name: "NoReverseMatch",
                message: message
            };
        }
        ,GenericError: function(message){
            return {
                name: "GenericError",
                message: message
            };
        }
        ,ImproperlyConfigured: function(message){
            return {
                name: "ImproperlyConfigured",
                message: message
            };
        }
        ,InvalidCacheBackendError: function(message){
            return {
                name: "InvalidCacheBackendError",
                message: message
            };
        }
        ,MultipleObjectsReturned: function(message){
            return {
                name: "MultipleObjectsReturned",
                message: message
            };
        }
        ,FieldDoesNotExist: function(message){
            return {
                name: "FieldDoesNotExist",
                message: message
            };
        }
        ,DoesNotExist: function(message){
            return {
                name: "DoesNotExist",
                message: message
            };
        }
        ,SettingsObjectNotDefined: function(message){
            return {
                name: "SettingsObjectNotDefined",
                message: message
            };
        }
        ,TemplateSyntaxError: function(message){
            return {
                name: "TemplateSyntaxError",
                message: message
            };
        }
        ,TemplateDoesNotExist: function(message){
            return {
                name: "TemplateSyntaxError",
                message: message
            };
        }
        ,TemplateEncodingError: function(message){
            return {
                name: "TemplateSyntaxError",
                message: message
            };
        }
        ,VariableDoesNotExist: function(message){
            return {
                name: "TemplateSyntaxError",
                message: message
            };
        }
    };
    
})();// original: https://github.com/brokenseal/pony
;(function(__global__, undefined){
	var
        Broker= function(settings){
			var
				instance= this
			;

			// allow instantiation without the new keyword
			if( !( this instanceof Broker ) ) {
				return new Broker(settings);
			}

			// private attribute, accessible only from the settings method
			this.settings= mergeWithDefaultSettings(settings || {});

			if(this.settings.queueMessages === true) {
				this.messageQueue= {};
			}

			this.subscriptionList= {};
			this.subscriptionQueue= {};
			this.subscribersTokenIndex= {};
			this.messageSubscriptionTokenIndex= {};

			if(this.settings.clearMessageQueueEvery) {
				this.startClearingMessageQueue();
			}

			return this;
		}

		// private shared variables
		,messageQueueObjectId= 0
		,subscriptionToken= 0

        /**
         *
         * @param object {
         *      instance
         *      message
         *      data
         *      synchronousPublish
         *      subscribers
         * }
         * @param callback
         */
		,publish= function(kwargs){
			var
				messageQueue
                ,instance= kwargs.instance
                ,message= kwargs.message
                ,data= kwargs.data
                ,synchronousPublish= kwargs.synchronousPublish
                ,subscribers= kwargs.subscribers

				,publicationObject
				,returnValues= []
				,subscribersLen
                ,callbackQueue= []
                ,len
                ,i
				,throwException= function(exception){
					throw exception;
				}
                ,deliveredMessageCount= 0
				,deliverMessage= function(subscriber, data){
					var
						returnValue
					;

					try {
						returnValue= subscriber.apply(context, data);
					} catch(e) {
						setTimeout(throwException, 0, e);
						return;
					} finally {
                        deliveredMessageCount+= 1;
                    }

					if(synchronousPublish) {
						returnValues.push(returnValue);
					} else if(instance.settings.queueMessages === true && publicationObject) {
						publicationObject.returnValues.push(returnValue);

                        if(deliveredMessageCount == subscribers.length && callbackQueue.length !== 0) {
                            for(i= 0, len= callbackQueue.length; i < len; i++) {
                                callbackQueue[i](publicationObject.returnValues);
                            }
                        }
					}
				}
			;

			subscribers= subscribers || instance.subscriptionList[ message ];
			subscribersLen= subscribers.length;

			// if there are no subscribers available for this particular message,
			// return false
			if(!subscribers || !subscribers.length) {
				return false;
			}

			// if the user wants the messages to be queued
			if(instance.settings.queueMessages === true) {
				// if the message queue for this particular message does not exist yet
				if(!instance.messageQueue.hasOwnProperty(message)) {
					// create it
					instance.messageQueue[ message ]= messageQueue= [];
				} else {
					// or retrieve it
					messageQueue= instance.messageQueue[ message ];
				}

				// Publication object specification
				// create a new message queue object
				publicationObject= {
					// give it a unique id
					id: messageQueueObjectId++
					// the data supplied for this particular publication
					,data: data
					// the amount of callbacks are subscribed to this particular message, right now
					,subscriptionCount: subscribersLen
                    // an array which is filled with all the return values taken from the
					,returnValues: []
                    // a possible callback function which wil be fired after all the current subscribers will be
                    // fired
                    ,complete: function(fn){
                        callbackQueue.push(fn);
                    }
				};

				// push the current publication object on to the queue
				messageQueue.push(publicationObject);
			}

			if(synchronousPublish) {
				while(subscribersLen--) {
					// deliver message right away, synchronously
					deliverMessage(subscribers[subscribersLen], data);
				}
			} else {
				while(subscribersLen--) {
					// deliver message whenever possible, without blocking any
					// other js or the  browser UI ( http://ejohn.org/blog/how-javascript-timers-work/ )
					setTimeout(deliverMessage, 0, subscribers[subscribersLen], data)
				}
			}

			if(synchronousPublish) {
				return returnValues;
			} else if(instance.settings.queueMessages === true && publicationObject) {
				return publicationObject;
			}

			return true;
		}

		,unsubscribeTokenFromInstance= function(instance, subscriptionToken ) {
			var
				tokenIndex= instance.subscribersTokenIndex[ subscriptionToken ]
				,message= instance.messageSubscriptionTokenIndex[ subscriptionToken ]
				,unsubscribedSubscriber
			;

			unsubscribedSubscriber= instance.subscriptionList[ message ].splice(tokenIndex, 1)[0]

	        if(instance.subscriptionList[ message ] === 0) {
				delete instance.subscriptionList[ message ];
			}

			delete instance.subscribersTokenIndex[ subscriptionToken ];
			delete instance.messageSubscriptionTokenIndex[ subscriptionToken ];

			return unsubscribedSubscriber;
		}
		,addSubscriberToInstance= function(instance, message, subscriber){
			// double index reference for easier unsubscriptions
			instance.subscribersTokenIndex[ subscriptionToken ]= instance.subscriptionList[ message ].push( subscriber ) - 1;
			instance.messageSubscriptionTokenIndex[ subscriptionToken ]= message;

			return subscriptionToken;
		}
		// default settings
		,defaultSettings= {
			// keep track of all the messages sent to the broker
			// if set, any subscriber which subscribe after a message has already been sent
			// will be called with this message queue as soon as it subscribes to that
			// particular message
			queueMessages: true

			// if set and queueMessages is set to true, it must be the number of
			// seconds after which the message queue will be cleared upon instantiation
			// very useful to do a garbage collection of useless messages published
			,clearMessageQueueEvery: 360 // every 5 minutes
		}

		// utility functions
		,mergeWithDefaultSettings= function(settings){
			var
				key
			;

			for(key in defaultSettings) {
				if(!(key in settings)) {
					settings[key]= defaultSettings[key];
				}
			}

			return settings;
		}
	;

	Broker.prototype= {

        // force contructor to be the Broker function
        constructor: Broker
		/**
		 *  Broker.subscribe( message [, *args ] ) -> String | Array
		 *  - message (String): the message to which all the given function will be subscribed to
		 *  - *args: any amount of functions that will be subscribed
		 *  This method subscribes all the given functions to this message and returns
		 *  a subscription token or a list of subscription tokens, with which it is possible
		 *  to unsubscribe all the functions
		**/
		,subscribe: function(message){
			var
				subscribers= Array.prototype.slice.call(arguments).slice(1)
				,subscriptionTokenList= []
				,i
				,subscribersLen
				,returnSubscriptionToken
                ,messageQueueLen
			;

			if(!this.subscriptionList.hasOwnProperty(message)) {
				this.subscriptionList[ message ]= [];
			}

			if(this.settings.queueMessages === true && this.messageQueue[ message ] && this.messageQueue[ message ].length) {
                messageQueueLen= this.messageQueue[ message ].length;
				// deliver previously published messages to new subscribers, asynchronously by default
				while(messageQueueLen--) {
					publish({
                        instance: this
                        ,message: message
                        ,subscribers: this.messageQueue[ message ][ messageQueueLen ].data
                        ,synchronousPublish: false
                        ,subscribers: subscribers
                    }, null);
				}
			}

			if(subscribers.length > 1) {
				for(i= 0, subscribersLen= subscribers.length; i < subscribersLen; i++) {
					subscriptionTokenList.push(addSubscriberToInstance(this, message, subscribers[i]));
					subscriptionToken+= 1;
				}

				return subscriptionTokenList;

			} else {
				returnSubscriptionToken= addSubscriberToInstance(this, message, subscribers[0]);
				subscriptionToken+= 1;
				return returnSubscriptionToken;
			}
		}

		/**
		 *  Broker.unsubscribe( subscriptionToken ) -> Function | Array
		 *  - token (String | Array): a subscription token or a list of subscription tokens
		 *  This method unsubscribes subscribers with the associated subscription token.
		 *  If an array of subscription token is provided, all the token will be used to unsubscribe
		 *  the subscribers.
		 *
		 *  The return value can be the unsubscribed function or an array of unsubscribed functions
		**/
		,unsubscribe: function(subscriptionToken){
			var
				subscriptionTokenLen
				,unsubscribedCallbacks
			;

			if(!subscriptionToken.length) {
				unsubscribedCallbacks= unsubscribeTokenFromInstance(this, subscriptionToken);
			} else {
				subscriptionTokenLen= subscriptionToken.length;
				unsubscribedCallbacks= [];

				while(subscriptionTokenLen--) {
					unsubscribedCallbacks.push(unsubscribeTokenFromInstance(this, subscriptionToken[ subscriptionTokenLen ]));
				}
			}

			return unsubscribedCallbacks;
		}

		/**
		 *  Broker.publish( message [, *args ] ) -> Boolean | Array | Publication object
		 *  - message (String): the message to publish on the current broker
		 *  - *args: any amount of arguments, past the message
		 *  This method publishes a particular message with any amount of data given to the function
		 *  It then returns a false boolean if no subscriber is found for this message,
		 *  it returns an Array of returned values from the subscribers called,
		 *  it returns a Publication object if a queue of messages is keps inside the broker
		 *  (please refer to the Publication object specification inside the private publish function)
		 *  or it returns  true boolean value for successfull calls
		**/
		,publish: function(message){
			var
				data= Array.prototype.slice.call(arguments).slice(1)
			;

			// TODO: callback as argument or as attribute of the passed publicationObject?

			return publish({
                instance: this
                ,message: message
                ,data: data
                ,synchronousPublish: false
            }, null);
		}

		/**
		 *  Broker.publishSync( message [, *args ] ) -> Boolean
		 *  - message (String): the message to publish on the current broker
		 *  - *args: any amount of arguments, past the message
		 *  This method publishes a particular message with any amount of data given to the function
		**/
		,publishSync: function(message){
			var
				data= Array.prototype.slice.call(arguments).slice(1)
			;

			return publish({
                instance: this
                ,message: message
                ,data: data
                ,synchronousPublish: true
            }, null);
		}

		/**
		 *  Broker.startClearingMessageQueue( ) -> Broker instance
		 *  It starts clearing message queue, based on the clearMessageQueueEvery setting
		**/
		,startClearingMessageQueue: function(){
			var
				instance= this
			;

			// if there is no interval already set
			if(!this.clearMessageQueueInterval && this.settings.clearMessageQueueEvery && this.settings.queueMessages) {
				// setup a new interval for clearing messages
				instance.clearMessageQueueInterval= setInterval(function(){
					instance.clearMessageQueue();
				}, this.settings.clearMessageQueueEvery * 1000);
			}

			return this;
		}

		/**
		 *  Broker.startClearingMessageQueue( ) -> Broker instance
		 *  It stop clearing message queue
		**/
		,stopClearingMessageQueue: function(){
			if(this.clearMessageQueueInterval) {
				clearInterval(this.clearMessageQueueInterval);
				this.clearMessageQueueInterval= null;
			}

			return this;
		}

		/**
		 *  Broker.startClearingMessageQueue( ) -> Broker instance
		 *  It clears the message queue
		**/
		,clearMessageQueue: function(){
			this.messageQueue= {};

			return this;
		}
	};
    
    broke.core.pubsub= {
        Broker: Broker
        ,broker: Broker()
    };
})(this);;(function(__global__, undefined){
	var
		exceptions= broke.exceptions
        ,settings= broke.conf.settings
	;
	
	broke.urlResolvers= {
        resolve: function(url, args, urlPatterns) {
            var
                view= null
                ,match= null
                ,i
                ,urlPattern
            ;

            urlPatterns= urlPatterns || builtins.getattr(settings.ROOT_URLCONF);
            args= args || [];
            
            for(i= 0; i< urlPatterns.length; i++) {
                urlPattern= urlPatterns[i];

                match= url.match(urlPattern[0]);

                if(match) {
                    if(match.length > 1) {
                        args= args.concat(match.slice(1));
                    }
                    view= urlPattern[1];

                    if(builtins.typeOf(view) == "string") {
                        view= builtins.getattr(view);
                    }

                    if(builtins.isFunction(view)) {

                        return [view, args];

                    } else if(builtins.isArray(view)) {

                        url= url.replace(match[0], '');
                        return broke.urlResolvers.resolve(url, args, view);

                    }
                }
            }

            throw exceptions.NotFound(gettext.gettext('Matching url not found.'));
        }
        ,reverse: function(namedUrl, args, urlPatterns, result) {
            var
                match= null
                ,i
                ,isInclude
                ,urlPattern
            ;

            urlPatterns= urlPatterns || builtins.getattr(settings.ROOT_URLCONF);
            result= result || '';
            args= args || [];

            for(i= 0; i< urlPatterns.length; i++) {
                urlPattern= urlPatterns[i];

                if(builtins.typeOf(urlPattern[1]) == "string") {
                    urlPattern[1]= builtins.getattr(urlPattern[1]);
                }

                isInclude= builtins.isArray(urlPattern[1]);

                if(isInclude) {
                    match= builtins.startsWith(namedUrl, urlPattern[2]);
                } else {
                    match= (namedUrl == urlPattern[2]);
                }

                if(match) {
                    if(isInclude) {
                        namedUrl= namedUrl.replace(urlPattern[2] + '-', '');
                        return broke.urlResolvers.reverse(namedUrl, args, urlPattern[1], urlPattern[0]);
                    } else {
                        result+= urlPattern[0];
                        result= builtins.interpolate(args, result.replace('^', '').replace('$', '').replace(/\(.*?\)/g, '%s'));

                        if(result.match(urlPattern[0])) {
                            return result;
                        } else {
                            return '';
                        }
                    }
                }
            }

            // no matching url found
            throw exceptions.NoReverseMatch(gettext.gettext('Matching url not found.'));

            return null;
        }
        ,replaceNamedUrls: function(){
            // TODO: is this really useful? Should I refactor it to search named urls on templates only?
            /*
             * Search for named urls on the page and swap them with full qualified urls
             * Named urls on the page should look like this:
             *     #entry-commit     ->    /blog/entry/commit/
             *     #entry-view       ->    /blog/entry/view/2/
             *     #entry-edit 21,2  ->    /blog/21/entry/edit/2/
             *
             * If any arguments are needed, they will have to be a comma separated
             * series of values after the named url
             *
             */

            var
                callback= function(urlChangingElement){
                    var
                        attr= broke.DOM.attr
                        ,urlAttribute= urlChangingElement.urlAttribute
                        ,urlToRender= attr(this, urlAttribute).split('#')[1] || ''
                        ,namedUrl
                        ,args
                        ,result
                    ;

                    if(attr(this, urlAttribute).contains('#')) {
                        urlToRender= urlToRender.trim().split(' ');

                        namedUrl= urlToRender[0];
                        args= urlToRender[1];
                        if(args) {
                            args= args.split(',');
                        } else {
                            args= [];
                        }

                        try {

                            result= broke.urlResolvers.reverse(namedUrl, args);
                            attr(this, urlAttribute, '#' + result);

                        } catch(e) {
                            if(e.name == "NoReverseMatch") {
                                return;
                            }
                        }
                    }
                }
            ;

            builtins.forEach(broke.conf.settings.URL_CHANGING_ELEMENTS, function(key){
                var
                    elements= broke.DOM.querySelector(key)
                    ,elementsLength= elements.length
                ;
                
                while(elementsLength--) {
                    callback.call(elements[elementsLength], this);
                }
            });
        }
    };
})(this);(function(context, undefined){
    var
        remoteModels= [
            'SlideContent'
            ,'Event'
            ,'PageTour'
            //,'PageTourStep'
        ]
        ,remoteModelsForRead= remoteModels.concat([])
        ,remoteModelsForWrite= remoteModels.concat([
            'Occurrence'
            //,'Slide'
        ])
    ;

    broke.db.routers= {};

    Class.create({
        __name__: "broke.db.routers.DefaultRouter"
        ,dbForRead: function(model, hints){
            if(builtins.has(remoteModelsForRead, model.__name__)) {
                return 'remote';
            }
        }
        ,dbForWrite: function(model, hints){
            if(builtins.has(remoteModelsForWrite, model.__name__)) {
                return 'remote';
            }
        }
    });
})(this);;(function(undefined){
    var
        JSONSchemaStorage= {} // the actual JSON used to store data
        ,JSONSchemaModelStorageMapping= {}
        ,cleanData= function(kwargs, model){
            var
                result= kwargs
                ,defaultPistonAttributeFieldsHolder
            ;

            if(model) {
                defaultPistonAttributeFieldsHolder= model.__name__.toLowerCase() + '_ptr';
            }

            if(defaultPistonAttributeFieldsHolder && kwargs[defaultPistonAttributeFieldsHolder]) {
                // support for default django piston json emitter
                result= {
                    pk: kwargs[defaultPistonAttributeFieldsHolder].pk
                    ,fields: kwargs[defaultPistonAttributeFieldsHolder]
                };

            } else if(!kwargs.fields) {
                // support for generic json emitter (???)

                result= {
                    pk: kwargs.pk
                    ,fields: kwargs
                };

            }

            return result;
        }
    ;

    broke.storages= {
        // TODO: change this with IndexedDb if available (?)
        JSONSchema: {
            index: {}
            ,position: {}
            ,autoPk: 0
            ,initTableForModel: function(model, objects){
                var
                    tableName= model.getTableName()
                ;

                if(JSONSchemaStorage[tableName] === undefined) {
                    JSONSchemaStorage[tableName]= objects || [];
                }

                // init pk index for this table
                broke.storages.JSONSchema.index[tableName]= {};
                
                JSONSchemaModelStorageMapping[tableName]= model;

                return JSONSchemaStorage[tableName];
            }
            ,getTable: function(tableName){
                return JSONSchemaStorage[tableName];
            }
            ,get: function(pk, tableName){
                // TODO: improve
                broke.storages.JSONSchema.index[tableName]= broke.storages.JSONSchema.index[tableName] || {};
                
                return broke.storages.JSONSchema.index[tableName][pk];
            }
            ,set: function(tableName, kwargs) {
                var
                    dbTable= JSONSchemaStorage[tableName]
                    ,i= dbTable.length
                    ,obj= this.get(kwargs.pk, tableName)
                    ,model= JSONSchemaModelStorageMapping[tableName]
                    ,position
                ;

                kwargs= cleanData(kwargs, model);

                if(!kwargs.pk) {
                    kwargs.pk= null;
                    broke.log("Objects must have a primary key!");
                }

                if(kwargs.pk == 'auto') {
                    kwargs.pk= 'new_' + broke.storages.JSONSchema.autoPk;
                    broke.storages.JSONSchema.autoPk+= 1;
                }
                
                if(obj) {
                    position= broke.storages.JSONSchema.position[kwargs.pk];
                    dbTable[position]= kwargs;
                    obj= kwargs;
                } else {
                    kwargs._meta= {
                        model: model
                    };

                    broke.storages.JSONSchema.index[tableName][kwargs.pk]= kwargs;
                    position= dbTable.push(kwargs);
                    broke.storages.JSONSchema.position[kwargs.pk]= position-1;
                }

                return kwargs;
            }
            ,'delete': function(tableName, pk){
                var
                    dbTable= JSONSchemaStorage[tableName]
                    ,position= broke.storages.JSONSchema.position[pk]
                ;

                builtins.remove(dbTable, position);
            }
        }
        ,localStorage: (function(){
            // mime or reference HTML 5's Local Storage
            var
                localStorageSetObject= function(key, value) {
                    this.setItem(key, JSON.stringify(value));
                }
                ,localStorageGetObject= function(key) {
                    return JSON.parse(this.getItem(key));
                }
                ,storage= {}
            ;
            
            if('localStorage' in window) {
                broke.extend(Storage.prototype, {
                    set: localStorageSetObject
                    ,get: localStorageGetObject
                });

                return localStorage;
            }

            return {
                key: function(key){
                    throw {
                        name: "NotImplementedError",
                        description: "Sorry, this version of localStorage is a fake and does not support key() method."
                    };
                }
                ,setItem: function(key, value){
                    storage[key]= value;
                    return this;
                }
                ,getItem: function(key){
                    return storage[key];
                }
                ,removeItem: function(key){
                    delete storage[key];
                    return this;
                }
                ,get: localStorageGetObject
                ,set: localStorageSetObject
                ,clear: function(){
                    storage= {};
                    return this;
                }
            };
        })()
    };
})();;(function(undefined){
    var
        settings= broke.conf.settings
        ,NotImplementedError= broke.exceptions.NotImplementedError
        ,BaseEngine
        ,LocalEngine
        ,OPERATIONS= {
            SELECT: 'select'
            ,INSERT: 'insert'
            ,UPDATE: 'update'
            ,DELETE: 'delete'
        }
        ,filterOperations= {
            contains: function(first, second){
                if(first.match(second)) {
                    return true;
                }
                return false;
            }
            ,iContains: function(first, second){
                return this.contains(first.toString().toLowerCase(), second.toString().toLowerCase());
            }
            ,startsWith: function(first, second){
                if(first.match("^" + second)) {
                    return true;
                }
                return false;
            }
            ,iStartsWith: function(first, second){
                    return this.startsWith(first.toString().toLowerCase(), second.toString().toLowerCase());
            }
            ,endsWith: function(first, second){
                if(first.match(second + "$")) {
                    return true;
                }
                return false;
            }
            ,iEndsWith: function(first, second){
                return this.EndsWith(first.toString().toLowerCase(), second.toString().toLowerCase());
            }
            ,exact: function(first, second){
                if(first.match("^" + second + "$")) {
                    return true;
                }
                return false;
            }
            ,iExact: function(first, second){
                return this.exact(first.toString().toLowerCase(), second.toString().toLowerCase());
            }
            ,'in': function(first, second){
                return builtins.has(second, first);
            }
            ,gt: function(first, second){
                return first > second;
            }
            ,gte: function(first, second){
                return first >= second;
            }
            ,lt: function(first, second){
                return first < second;
            }
            ,lte: function(first, second){
                return first <= second;
            }
            ,regex: function(first, second){
                return first.match(second);
            }
            ,iRegex: function(first, second){
                return this.regex(first.toString().toLowerCase(), second.toString().toLowerCase());
            }
            ,isNull: function(first, second) {
                return (first === null || first === undefined) ? second : !second;
            }
            ,year: function(first, second) {
                return (new Date(first).getFullYear()) == second;
            }
            ,month: function(first, second) {
                return (new Date(first).getMonth() + 1) == second;
            }
            ,day: function(first, second) {
                return (new Date(first).getDate()) == second;
            }
            ,weekDay: function(first, second) {
                return (new Date(first).getDay()) == second;
            }
            ,range: function(first, second) {
                return (second[0] <= first) && (first <= second[1]);
            }
        }
        ,applyFilters= function(engine, data, args, negate){
            var
                Model= broke.db.models.Model
            ;
            negate= negate === undefined ? true : negate;

            return builtins.filter(data, function(){
                var
                    splitData= null
                    ,filterOperation= null
                    ,key= null
                    ,newKey= null
                    ,relatedObjectFilterOptions= {}
                    ,relatedResult
                    ,value
                    ,data= this
                ;
                
                for(key in args) {
                    if(args.hasOwnProperty(key)) {
                        
                        /*if(!(key in this.fields)) {
                            throw broke.exceptions.FieldError(builtins.interpolate(gettext.gettext("The specified field (%s) is not available."), key));
                        }*/
                        
                        splitData= key.split('__');
                        
                        if(splitData.length > 1) {
                            newKey= splitData[0];
                            filterOperation= splitData[1];
                            
                            if(filterOperation in filterOperations) {
                                
                                if(!filterOperations[filterOperation](this.fields[newKey], args[key])) {
                                    return !negate;
                                }
                                
                            } else if(builtins.typeOf(this.fields[newKey]) == "object"){
                                try {
                                    relatedResult= builtins.getattr(splitData.join('.'), this.fields, null);
                                    
                                    if(relatedResult == args[key]) {
                                        return negate;
                                    }
                                    
                                } catch(e) {}
                                
                                return !negate;
                                
                            } else {
                                throw broke.exceptions.NotImplementedError(builtins.interpolate(gettext.gettext("Filter operation '%s' not implemented."), filterOperation));
                            }
                        } else if(args[key] instanceof Model && this.fields[key] instanceof Model) {
                            try {
                                    if(args[key].pk !=  this.fields[key].pk) {
                                            return !negate;
                                    }
                            } catch(e) {}
                            
                            return negate;
                            
                        } else if(key == "pk" && this[key] == args[key]) {
                            return negate;
                        } else if(this.fields[key] != args[key]) {
                            return !negate;
                        }
                    }
                }
                return negate;
            });
        }
        ,saveRelatedObjectsOnLocalEngine= function(objects){
            
            builtins.forEach(objects, function(){
                var
                    object= this
                ;
                
                builtins.forEach(this.fields, function(key){
                    var
                        relatedField
                    ;
                    
                    if(builtins.typeOf(this) == "array") {
                        relatedField= object[key];
                        
                        if(relatedField) {
                            builtins.forEach(this, function(){
                                LocalEngine({
                                    model: relatedField.model
                                    ,args: {
                                        insert: this
                                    }
                                    ,operation: OPERATIONS.INSERT
                                }).execute();
                            });
                        }
                    }
                    
                });
                
            });
        }
    ;

    broke.db.engines= {
        OPERATIONS: OPERATIONS
    };

    BaseEngine= Class.create({
        __name__: "broke.db.engines.BaseEngine"
        ,__init__: function(kwargs){
            this.model= kwargs.model;
            this.args= kwargs.args;
            this.operation= kwargs.operation;
            this.settings= kwargs.settings;
            this.object= kwargs.object;
        }
        ,select: function(){
            throw NotImplementedError("You need to implement this method on every class that extends this one.");
        }
        ,insert: function(){
            throw NotImplementedError("You need to implement this method on every class that extends this one.");
        }
        ,update: function(){
            throw NotImplementedError("You need to implement this method on every class that extends this one.");
        }
        ,'delete': function(){
            throw NotImplementedError("You need to implement this method on every class that extends this one.");
        }
        ,execute: function(callback){
            var
                engine= this
                ,executeCallback= function(operationResult, status, xhr, error){
                    var
                        result
                    ;

                    if(operationResult && builtins.typeOf(operationResult) == "array") {

                        result= builtins.map(operationResult, function(){
                            return engine.model(this);
                        });

                        saveRelatedObjectsOnLocalEngine(result);

                    } else if(builtins.typeOf(operationResult) == "object") {
                        result= engine.model(operationResult);

                        saveRelatedObjectsOnLocalEngine([result]);
                    }
                
                    if(callback) {
                        callback(result, status, xhr, error);
                    }
                }
            ;

            return this[this.operation](executeCallback);
        }
    });

    LocalEngine= BaseEngine.create({
        __name__: "broke.db.engines.LocalEngine"
        ,storage: broke.storages.JSONSchema
        ,select: function(callback){
            var
                data= this.storage.getTable(this.model.getTableName())
            ;
            
            data= applyFilters(this, data, this.args.filter);
            data= applyFilters(this, data, this.args.exclude, true);

            callback(data);
        }
        ,insert: function(callback){
            var
                engine= this
                ,objects
                ,dataTableName= this.model.getTableName()
                ,data
            ;

            if(builtins.typeOf(this.args.insert) == "array") {
                data= [];

                builtins.forEach(this.args.insert, function(){
                    data.push(this.storage.set(dataTableName, this));
                });
            } else {
                data= this.storage.set(dataTableName, this.args.insert);
            }
            
            callback(data);
        }
        ,update: function(callback){
            return this.insert(callback);
        }
        ,'delete': function(callback){
            // TODO
        }
        ,orderBy: function(){
            // TODO
            /*
            var
                index= this.length
                ,fieldValueList= []
                ,tmpValue
                ,querySet= this
            ;
            
            //if(typeOf(field) != 'string' && typeOf(field) != 'number') {
            //	throw new TypeError('Order by works with strings and number types only!');
            //}
            
            while(index--) {
                tmpValue= querySet[index].fields[field];
                tmpValue= new tmpValue.constructor(tmpValue);
                
                tmpValue.__index__= index;
                fieldValueList.push(tmpValue);
            }
            fieldValueList.sort();
            
            builtins.forEach(fieldValueList, function(){
                var
                    obj= querySet[this.__index__]
                ;
                
                delete this.__index__;
                
                querySet.push(obj);
            });
            
            */
            
            return this;
        }
    });
    LocalEngine.initTableForModel= function(model, objects){
        return this.prototype.storage.initTableForModel(model, objects);
    };
    
    RemoteEngine= BaseEngine.create({
        __name__: "broke.db.engines.RemoteEngine"
        ,select: function(callback){
            return this._ajaxOperation({
                data: this.args.filter
                ,type: 'GET'
                //,success: function(data, status, xhr){
                //    callback(data, status, xhr);
                //}
            },callback);
        }
        ,insert: function(callback){
            return this._ajaxOperation({
                data: this.args.insert.fields
                ,type: 'POST'
                ,success: function(data, status, xhr){
                    data= builtins.typeOf(data) == "array" ? data[0] : data;
                    
                    if(callback){
                        callback(data, status, xhr, null);
                    }
                }
            }, callback);
        }
        ,update: function(callback){
            return this._ajaxOperation({
                data: this.args.update
                ,type: 'PUT'
                ,url: this.object.remoteUrls.update
                ,success: function(data, status, xhr){
                    data= builtins.typeOf(data) == "array" ? data[0] : data;
                    
                    if(callback){
                        callback(data, status, xhr);
                    }
                }
            }, callback);
        }
        ,'delete': function(callback){
            return this._ajaxOperation({
                type: 'DELETE'
                ,url: this.object.remoteUrls['delete']
            }, callback);
        }
        ,orderBy: function(){
            // TODO
        }
        ,_ajaxOperation: function(ajaxSettings, callback){
            ajaxSettings= broke.extend({
                async: this.settings.async
                ,cache: this.settings.cache === undefined ? false : this.settings.cache
                ,url: this.model.getBaseRemoteUrl()
                ,success: function(data, status, xhr){
                    if(callback){
                        callback(data, status, xhr);
                    }
                }
                ,error: function(xhr, status, error){
                    if(callback){
                        callback(null, status, xhr, error);
                    }
                }
            }, ajaxSettings);

            return $.ajax(ajaxSettings);
        }
    });
})();(function(context, undefined){
    var
        Field
        ,ForeignKey
        ,CharField
        ,TextField
        ,BooleanField
        ,PositiveIntegerField
        ,getter= function(){}
        ,setter= function(){}
    ;
    
    Field= Class.create({
        __name__: "broke.db.fields.Field"
        ,__init__: function(kwargs){
            this['default']= kwargs['default'];
        }
        ,get: function(instance){
            return instance.fields[this.fieldName] || this['default'];
        }
        ,attachCurrentModelInstance: true
        ,contributeToClass: function(cls, fieldName){
            //this.setAttributesFromName(fieldName);
            this.model= cls;
            this.fieldName= fieldName;
        }
    });
    
    ForeignKey= Field.create({
        __name__: "broke.db.fields.ForeignKey"
        ,__init__: function(kwargs){
            this._super(kwargs);
            
            this.relatedModel= kwargs.model;
            if(kwargs.relatedName) {
                this.relatedName= kwargs.relatedName;
            }
        }
        ,contributeToClass: function(cls, fieldName){
            this._super(cls, fieldName);
            this.contributeToRelatedClass(cls, fieldName);
        }
        ,contributeToRelatedClass: function(cls, fieldName){
            var
                fieldInstance= this
                ,getRelatedModels= function(){
                    return cls.objects.filter({
                        pk: this.instance.fields[fieldName]
                    });
                }
            ;
            
            if(!this.relatedName) {
                this.relatedName= cls.__name__.toLowerCase() + '_set';
            }
            
            this.relatedModel.prototype[this.relatedName]= getRelatedModels;
            
            // is it the best way to handle this? not sure...
            getRelatedModels.model= cls;
        }
        ,get: function(instance, callback){
            var
                pk= instance.fields[this.fieldName] || instance.fields[this.fieldName + '_id']
            ;
            
            this.relatedModel.objects.get({
                pk: pk
            }, callback);
        }
    });
    
    PositiveIntegerField= Field.create({
        __name__: "broke.db.fields.PositiveIntegerField"
        ,set: function(instance, value){
            if(value < 0 || parseInt(value) === NaN) {
                throw new Error("A PositiveIntegerField only accepts a positive integer field.");
            }

            instance.fields[this.fieldName]= value;
            
            return value;
        }
    });

    BooleanField= Field.create({
        __name__: "broke.db.fields.BooleanField"
        ,set: function(instance, value){
            if(builtins.typeOf(value) != "boolean") {
                throw new Error("A BooleanField only accepts a boolean values.");
            }
            
            instance.fields[this.fieldName]= value;

            return value;
        }
    });

    TextField= Field.create({
        __name__: "broke.db.fields.TextField"
        ,set: function(instance, value){
            instance.fields[this.fieldName]= value;
            
            return value;
        }
    });
    
    CharField= TextField.create({
        __name__: "broke.db.fields.CharField"
        ,__init__: function(kwargs){
            this._super(kwargs);
            
            this.max_length= kwargs.max_length;
        }
        ,set: function(instance, value){
            if(value.length > this.max_length) {
                throw new Error("Value exceeds set max length");
            }
            instance.fields[this.fieldName]= value;
            
            return value;
        }
    });

    // TODO: DateField

    // make all the fields available as broke.db.models attributes
    broke.extend(broke.db.models, broke.db.fields);
})(this);(function(){
    var
        QuerySet
        ,engineOperations= broke.db.engines.OPERATIONS
        ,settings= broke.conf.settings
    ;

    /*************************************************************************/
    /************************** BASE QUERYSET CLASS **************************/
    /*************************************************************************/
    QuerySet= Class.create({
        __name__: "broke.db.models.QuerySet"
        ,__init__: function(kwargs){
            var
                routers= settings.DATABASE_ROUTERS
                ,routersLen= routers.length
                ,i
                ,dbForRead
                ,dbForWrite
                ,router
            ;
            
            this.model= kwargs.model;
            this.db= kwargs.db;
            this.args= {
                filter: {}
                ,exclude: {}
                ,insert: {}
                ,orderBy: {}
                ,'delete': {}
            };
            this._settings= kwargs.settings || {};
            
            broke.extend(this.args, kwargs.args);
            
            if(this.db) {
                this.dbForRead= this.db;
                this.dbForWrite= this.db;
            } else {
                this.dbForRead= broke.db.models.getDbForReadFromModel(this.model);
                this.dbForWrite= broke.db.models.getDbForWriteFromModel(this.model);
            }
            
            this.engineForRead= builtins.getattr(settings.DATABASES[this.dbForRead].ENGINE);
            this.engineForWrite= builtins.getattr(settings.DATABASES[this.dbForWrite].ENGINE);
        }
        ,settings: function(settings){
            broke.extend(this._settings, settings);

            return this;
        }
        ,exclude: function(args){
            this.args.exclude= args;

            return this.__class__({
                model: this.model
                ,args: this.args
                ,settings: this._settings
                ,db: this.db
            });
        }
        ,filter: function(args){
            this.args.filter= args;
            
            return this.__class__({
                model: this.model
                ,args: this.args
                ,settings: this._settings
                ,db: this.db
            });
        }
        ,create: function(args, callback){
            if(builtins.typeOf(args) == "function") {
                callback= args;
                args= undefined;
            }
            this.args.insert= args;
            
            this.engineForWrite({
                operation: engineOperations.INSERT
                ,model: this.model
                ,args: this.args
                ,settings: this._settings
            }).execute(callback);
        }
        ,getOrCreate: function(args, callback){
            try {
                return this.get(args, callback);
            } catch(e) {
                if(e.name == 'DoesNotExist') {
                    return this.create(args);
                }
                
                throw e;
            }
        }
        ,get: function(args, callback){
            var
                querySet= this
                ,getCallback= function(object){
                    if(object.length > 1) {
                        throw broke.exceptions.MultipleObjectsReturned(builtins.interpolate(gettext.gettext("get() returned few %s instances -- it returned %s! Lookup parameters were %s"), querySet.model.__name__, object.length, args));
                    }
                    if(!object.length) {
                        throw broke.exceptions.DoesNotExist(builtins.interpolate(gettext.gettext("%s matching query does not exist."), querySet.model.__name__));
                    }

                    if(callback){
                        callback(object[0]);
                    }
                }
            ;
            
            if(callback === undefined) {
                callback= args;
                args= undefined;
            }

            if(args) {
                this.filter(args).all(getCallback);
            } else {
                this.all(getCallback);
            }
        }
        ,latest: function(field, callback){
            if(callback === undefined) {
                callback= field;
                field= undefined;
            }
            field= field || settings.GET_LATEST_BY;

            return this.orderBy(field).all(callback)[0];
        }
        ,orderBy: function(fields){
            if(builtins.typeOf(fields) == "string") {
                fields= [ fields ];
            }
            this.args.orderBy= fields;
            
            return this.__class__({
                model: this.model
                ,args: this.args
                ,settings: this._settings
                ,db: this.db
            });
        }
        ,all: function(settings, callback){
            if(callback === undefined) {
                callback= settings;
                settings= undefined;
            }
            
            this.engineForRead({
                operation: engineOperations.SELECT
                ,model: this.model
                ,args: this.args
                ,settings: this._settings
            }).execute(callback);
        }
        ,'delete': function(callback){
            this.engineForWrite({
                operation: engineOperations.DELETE
                ,model: this.model
                ,args: this.args
                ,settings: this._settings
            }).execute(callback);
        }
    });
})();
(function(){
    var
        LocalQuerySet= broke.db.models.LocalQuerySet
        RemoteQuerySet= broke.db.models.RemoteQuerySet
        ,QUERY_TYPE= broke.conf.settings.QUERY_TYPE
    ;

    /*************************************************************************/
    /****************************** MANAGER **********************************/
    /*************************************************************************/
    Class.create({
        __parent__: window
        ,__name__: "broke.db.models.Manager"
        ,__init__: function(model){
            this.model= model;
        }
        ,all: function(callback){
            return this.getQuerySet().all(callback);
        }
        ,create: function(args, callback){
            return this.getQuerySet().create(args, callback);
        }
        ,exclude: function(args){
            return this.getQuerySet().exclude(args);
        }
        ,filter: function(args){
            return this.getQuerySet().filter(args);
        }
        ,get: function(args, callback){
            return this.getQuerySet().get(args, callback);
        }
        ,getOrCreate: function(args, callback){
            return this.getQuerySet().getOrCreate(args, callback);
        }
        ,getQuerySet: function(){
            return new broke.db.models.QuerySet({ model: this.model, db: this.db });
        }
        ,settings: function(settings){
            return this.getQuerySet().settings(settings);
        }
        ,latest: function(args, callback){
            return this.getQuerySet().latest(args, callback);
        }
        ,using: function(db){
            this.db= db;
            return this;
        }
    });
})();
;(function(undefined){
    var
        Model
        ,models= broke.db.models
        ,Manager= models.Manager
        ,elementsCache= {}
        ,contentTypeCache= {}
    ;
    
    broke.extend(broke.db.models, {
        addContentType: function(appLabel, modelName, model){
            if(contentTypeCache[appLabel] === undefined) {
                contentTypeCache[appLabel]= {};
            }
            
            contentTypeCache[appLabel][modelName]= model;
        }
        ,getDbFromModel: function(operation, model){
            var
                routers= broke.conf.settings.DATABASE_ROUTERS
                ,routersLen= routers.length
                ,db
            ;   
            
            // retrieve db for read
            for(i= 0; i< routersLen; i++) {
                router= builtins.getattr(routers[i])();
                db= router[operation](model);
                
                if(db) {
                    return db;
                }
            }
            
            return 'default';
        }
        ,getDbForReadFromModel: function(model){
            return broke.db.models.getDbFromModel('dbForRead', model);
        }
        ,getDbForWriteFromModel: function(model){
            return broke.db.models.getDbFromModel('dbForWrite', model);
        }
        ,getModel: function(appLabel, modelName){
            return contentTypeCache[appLabel][modelName];
        }
        ,compareObjects: function(firstObject, secondObject){
            if(firstObject.__class__.__fullname__ == secondObject.__class__.__fullname__ && firstObject.pk == secondObject.pk) {
                return true;
            }
            
            return false;
        }
        ,fetchDataForModel: function(model, args){
            // TODO: is this still useful? if yes, it needs refactor
            var
                settings= broke.conf.settings
                ,url= args.url || builtins.interpolate(settings.JSON_URLS.getData, {
                    appLabel: model.appLabel
                    ,model: model.className.toLowerCase()
                })
                ,filter= args.filter || {}
                ,result
                ,defaultDbEngine= builtins.getattr(settings.DATABASES['default'].ENGINE);
            ;

            $.ajax({
                async: false,
                type: "GET",
                url: url,
                data: filter,
                dataType: settings.AJAX.dataType,
                error: function(xhr, status, error){
                    result= error;
                },
                success: function(data, status){
                    defaultDbEngine.initTableForModel(model, data);
                    result= data;
                }
            });

            return result;
        }
    });
    
    /*************************************************************************/
    /******************************* MODEL ***********************************/
    /*************************************************************************/

    Class.create({
        __name__: "broke.db.models.ModelMetaClass"
        ,__init__: function(__class__){
            var
                defaultManager
                ,currentModel= this
            ;
            
            __class__.objects= Manager(__class__);
            __class__.appLabel= __class__.__fullname__.split('.').slice(-3, -2)[0];

            currentModel._meta.appLabel= __class__.appLabel;
            currentModel._meta.modelName= __class__.__name__.toLowerCase();

            // init fields which contribute to the class
            builtins.forEach(__class__.prototype, function(key){
                if(this instanceof Manager && defaultManager === undefined) {
                    defaultManager= this;
                }

//                if(this._field) {
//                    currentModel._meta.fields[key]= this;
//                }
                
                if(this.contributeToClass) {
                    this.contributeToClass(__class__, key);
                }
            });

            __class__._defaultManager= defaultManager || __class__.objects;
        }
        ,_meta: {
            fields: {}
        }
        // exceptions
        ,DoesNotExist: broke.exceptions.DoesNotExist
        ,MultipleObjectsReturned: broke.exceptions.MultipleObjectsReturned
        ,getTableName: function(){
            if(!this._tableName){
                this._tableName= [this.appLabel, this.__name__.toLowerCase()].join('_');
            }
            
            return this._tableName;
        }
        ,getObjectFromElement: function(element, callback){
            var
                model
                ,objectPk= element.attr('data-pk')
                ,appLabel= element.attr('data-app_label')
                ,model= this.__name__.toLowerCase()
            ;
            
            models.getModel(appLabel, model)._defaultManager.getOrCreate({ pk: objectPk }, callback);
        }
        ,getBaseRemoteUrl: function(){
            if(!this._remoteBaseUrl) {
                this._remoteBaseUrl= broke.conf.settings.API_BASE_URL + this.__name__.toLowerCase() + '/'
            }
            
            return this._remoteBaseUrl;
        }
    });
    
    Model= Class.create({
        __name__: "broke.db.models.Model"
        ,__metaclass__: broke.db.models.ModelMetaClass
        ,__init__: function(args, inheritedFields){
            var
                baseUrl= this.__class__.getBaseRemoteUrl()
                ,currentInstance= this
                ,tmpArgs
                ,key
            ;
            
            // TODO: add a an adapter for piston and django type of data
            if(args.fields === undefined) {
                tmpArgs= {};
                tmpArgs.fields= args;
                tmpArgs.pk= args.pk || args.id;
                args= tmpArgs;
            }
            
            // extend current object
            broke.extend(this, args || {});
            
            // init primary key
            if(this.pk) {
                this.fields.pk= this.pk;
            }
            
            // init remote urls
            this.remoteUrls= {
                get: baseUrl
                ,save: baseUrl
                ,update: baseUrl + this.pk + '/'
                ,'delete': baseUrl + this.pk + '/'
            };
            
            // attach the current instance to all the fields of this model's instance
            builtins.forEach(this.__class__.prototype, function(key){
                var
                    field
                ;

                if(this instanceof broke.db.fields.Field) {

                    field= this;
                    
                    currentInstance[key]= function(value){
                        if(value !== undefined) {
                            return field.set(currentInstance, value);
                        } else {
                            return field.get(currentInstance);
                        }
                    }
                    
                }
            });
        }
        ,fields: {}
        ,elements: function(kwargs){
            // element identifier : e.g. entry_21
            // TODO: change it to use content types
            var
                extraFilter
                ,context= document
                ,clearCache
                ,elements
                ,filterExpression
            ;
            
            if(kwargs) {
                extraFilter= kwargs.filter || '';
                context= kwargs.context || document;
                clearCache= kwargs.clearCache;
                filterExpression= kwargs.filterExpression || '';
            }
            
            filterExpression= filterExpression || '[data-pk="' + this.fields.pk + '"]'+
                    '[data-app_label="' + this.__class__.appLabel + '"]'+
                    '[data-model="' + this.__class__.__name__.toLowerCase() + '"]';
            
            clearCache= clearCache === undefined ? false : clearCache;
            
            if(!elementsCache[filterExpression]) {
                clearCache= true;
            }
            
            if(clearCache) {
                elements= broke.DOM.querySelector(filterExpression, context);
                
                if(extraFilter) {
                    elements= broke.DOM.m.filter(elements, extraFilter);
                }
                
                elementsCache[filterExpression]= elements;
            }
            
            return elementsCache[filterExpression];
        }
        ,getForm: function(formSetParent){
            if(!this.form) {
                this.form= broke.forms.Form({
                    instance: this
                    ,formSetParent: formSetParent
                });
            }
            
            return this.form;
        }
        ,getAbsoluteUrl: function(){
                return '';
        }
        ,getOperation: function(del){
            if(del !== undefined && this.fields.pk) {
                return 'delete';
            }
            else if(this.fields.pk) {
                return 'update';
            }
            
            return 'create';
        }
        ,processFields: function(){
            var
                data= {}
            ;
            
            builtins.forEach(this.fields, function(key){
                if(this instanceof Model) {
                    
                    data[key]= this.pk.toString();
                    
                } else if(builtins.typeOf(this) == "object" && (this.pk || this.id)) {
                    data[key]= this.pk || this.id;
                } else if(builtins.startsWith(key, '_')) {
                    // do nothing
                    
                    return;
                } else if(this !== undefined) {
                    
                    data[key]= this.toString();
                    
                }
            });

            return data;
        }
        ,update: function(fields, updateDOM){
            var
                instance= this
            ;
            updateDOM= updateDOM === undefined ? true : updateDOM;

            broke.extend(this.fields, fields);

            if(updateDOM) {
                // asynchronously update instance's elements
                setTimeout(function(){
                    var
                        elements= instance.elements({ clearCache: true })
                    ;

                    builtins.forEach(fields, function(key){
                        var
                            result= broke.DOM.querySelector('[data-field="' + key + '"]', elements)
                        ;

                        if(builtins.typeOf(this) == "boolean") {
                            if(this == true) {
                                broke.DOM.attr(result, 'checked', 'checked');
                            } else {
                                broke.DOM.removeAttr(result, 'checked');
                            }
                        } else {
                            broke.DOM.text(result, this);
                        }
                    });
                }, 0);
            }
            
            return this;
        }
        ,save: function(saveSettings, callback){
            // TODO: clean up this mess
            var
                object= this
                ,className= object.__class__.__name__.toLowerCase()
                ,operation
                ,serverOperation
                ,apiBaseUrl= broke.conf.settings.API_BASE_URL
                ,operationsMap= {
                    'save': 'POST'
                    ,'update': 'PUT'
                    ,'delete': 'DELETE'
                }
                ,data= {}
                ,created= true
                ,overrideLocalData
                ,using
                ,dbForWrite
                ,engineForWrite
                ,engineOperation= 'insert'
                ,engineOperationArgs= {
                    insert: {}
                    ,update: {}
                    ,'delete': {}
                }
            ;

            if(builtins.typeOf(saveSettings) == 'function') {
                callback= saveSettings;
                saveSettings= {};
            }
            
            saveSettings= saveSettings || {};
            url= saveSettings.url || apiBaseUrl + className + '/';
            overrideLocalData= saveSettings.overrideLocalData === undefined ? true : saveSettings.overrideLocalData;
            
            // using
            dbForWrite= saveSettings.using;
            
            // load defaults on save settings
            saveSettings= broke.extend(builtins.clone(broke.conf.settings.SAVE), saveSettings);
            
            operation= saveSettings.operation ? 'delete' : 'save';
            
            // trigger model pre_save event
            broke.DOM.events.trigger(window, 'broke.' + className + '.pre_' + operation, [object]);
            
            if(operation == 'save' && object.pk) {
                serverOperation= 'update';
                engineOperation= 'update';
            } else if(operation == 'save') {
                engineOperation= 'insert';
            } else if(operation == 'delete' && !object.pk){
                // TODO
                //throw new Error("? ^^");
            } else {
                serverOperation= operation;
                engineOperation= operation;
            }
            
            if(this.pk && operation != 'save') {
                url += object.pk + '/';
            }
            
            data= this.processFields();
            engineOperationArgs[engineOperation]= data;
            
            dbForWrite= dbForWrite !== undefined ? dbForWrite : broke.db.models.getDbForWriteFromModel(this.__class__);
            engineForWrite= builtins.getattr(broke.conf.settings.DATABASES[dbForWrite].ENGINE);
            
            // mark this object as being deleted
            this.fields._deleted= true;
            
            if(saveSettings.commit) {
                return engineForWrite({
                    operation: engineOperation
                    ,model: this.__class__
                    ,object: this
                    ,args: engineOperationArgs
                    ,settings: saveSettings
                }).execute(function(data, status, xhr, error){

                    broke.DOM.events.trigger(window, 'broke.' + className + '.post_' + engineOperation, [object]);

                    if(callback) {
                        callback(data);
                    }
                    
                });
            }
        }
        ,'delete': function(settings, callback){
            var
                instance= this
            ;

            if(builtins.typeOf(settings) == "function") {
                callback= settings;
                settings= {};
            }
            settings= settings || {};
            
            this.fields._deleted= true;
            
            settings.operation= 'delete';

            setTimeout(function(){
                instance.elements({ clearCache: true }).remove();
            }, 0);

            return this.save(settings, callback);
        }
    });
    
    builtins.forEach(broke.db.fields, function(key){
        broke.db.models[key]= this;
    });
})();broke.forms= {};(function(){
    var
        saveAsAjaxRequest= function(data){
            var result;
            
            $.ajax({
                async: false
                ,method: 'POST'
                ,data: data
                ,success: function(status){
                    result= status;
                }
                ,error: function(status){
                    result= status;
                }
            });
            
            return result;
        }
        ,saveAsFormPost= function(data){
            var
                form= broke.DOM.m.create('form', {
                    action: '.'
                    ,method:'post'
                    ,style:'display:none;'
                })
                ,field= broke.DOM.m.create('textarea')
                ,newField
                ,body= broke.DOM.m.querySelector('body')
            ;
            
            builtins.forEach(data, function(key){
                newField= broke.DOM.m.clone(field);
                broke.DOM.attr(newField, 'name', key);
                
                if(builtins.typeOf(this) == "boolean") {
                    if(this == true) {
                        broke.DOM.val(newField, 'on');
                        broke.DOM.m.append(newField, form);
                    }
                } else if(builtins.typeOf(this) == "array") {
                    builtins.forEach(this, function(){
                        newField= broke.DOM.m.clone(field);
                        broke.DOM.val(newField, this);
                        broke.DOM.attr(newField, 'name', key);
                        broke.DOM.m.append(newField, form);
                    });
                } else {
                    broke.DOM.val(newField, this);
                    broke.DOM.m.append(newField, form);
                }
            });
        
            broke.DOM.m.append(form, body);
            broke.DOM.e.trigger(form, 'submit');
                
            return form;
        }
    ;
    
    Class.create({
        __name__: "broke.forms.Form"
        ,__init__: function(kwargs){
            /*
                kwargs: {
                    instance
                    formSetParent
                }
            */
            
            broke.extend(this, kwargs);
        }
        ,save: function(settings){
            var
                useAjax= settings.useAjax || broke.conf.settings.useAjax
                ,result
                ,prefix= settings.prefix || ''
                ,form= this
                ,data= {}
            ;
            
            // putting all the data from the object into the form
            builtins.forEach(this.instance.getData(), function(key){
                data[prefix + key]= this;
            });
            
            if(this.formSetParent) {
                // if this form is part of a formset, it won't post itself to the server
                // but rather return itself to the formset parent's save method
                return data;
                
            } else if(useAjax) {
                
                result= saveAsAjaxRequest(data);
                
            } else {
                
                result= saveAsFormPost(data);
                
            }
            
            return result;
        }
    });
    
    Class.create({
        __name__: "broke.forms.FormSet"
        ,__init__: function(kwargs){
            /*
                kwargs: {
                    instance
                    relatedObjects
                    forms
                    initialForms
                    prefix
                }
            */
            
            broke.extend(this, kwargs);
        }
        ,save: function(settings){
            var
                useAjax
                ,result
                ,data= {}
                ,commit
                ,count= 0
                ,formSet= this
            ;
            
            settings= settings || {};
            commit= settings.commit || false;
            //useAjax= settings.useAjax || broke.conf.settings.AJAX;
            
            // formset management data
            data[this.prefix+'-TOTAL_FORMS']= this.forms.length;
            data[this.prefix+'-INITIAL_FORMS']= this.initialForms;
            
            // get this formset instance's data
            broke.extend(data, this.instance.getData());
            
            // formset's forms data
            builtins.forEach(this.forms, function(){
                
                broke.extend(data, this.save({
                    prefix: formSet.prefix + '-' + count + '-'
                }));
                
                count+= 1;
            });
            
            if(settings.extraData){
                broke.extend(data, settings.extraData);
            }
            
            if(useAjax) {
                
                result= saveAsAjaxRequest(data);
                
            } else {
                
                result= saveAsFormPost(data);
                
            }
            
            return result;
        }
    });
})();/**
 * Heavily inspired by http://www.html5rocks.com/en/tutorials/file/filesystem/
 * API copied from NodeJS file system api at http://nodejs.org/docs/latest/api/fs.html which exposes standard POSIX functions
 */

(function(__global__, undefined){
    var
        requestFileSystem= __global__.requestFileSystem || __global__.webkitRequestFileSystem
        ,settings= broke.conf.settings
        ,KB= 1024
        ,MB= KB * KB
        ,GB= MB * KB
        ,TB= GB * KB

        // utility functions
        ,getFileSystem= function(callback){
            var
                type= settings.FILE_SYSTEM.PERSISTENT ? __global__.PERSISTENT : __global__.TEMPORARY
            ;

            if(requestFileSystem === undefined) {
                throw new Error("This browser does not support the HTML5 file system API.");
            }

            requestFileSystem(type, settings.FILE_SYSTEM.SIZE, function(fs){

                callback(fs);

            }, function(error){
                throw error;
            });

        }
        /**
         * Splits directory from file from the path given
         */
        ,splitPath= function(path){
            var
                tmpSplitPath= path.split('/')
                ,dirPath= tmpSplitPath.slice(0, -1).join('/')
                ,fileName= tmpSplitPath.slice(-1)[0]
            ;

            return [ dirPath, fileName ];
        }
    ;

    broke.fs= {
        KB: KB
        ,MB: MB
        ,GB: GB
        ,TB: TB
        
        // File.seek whence constants
        ,SEEK_SET: 0
        ,SEEK_CUR: 1
        ,SEEK_END: 2
        
        ,open: function(path, flags, callback){
            broke.fs.File(path, flags, callback);
        }
        ,unlink: function(path, callback){
            fs.root.getFile(path, {
                create: false
            }, function(fileEntry){
                fileEntry.remove(function(){
                    callback();
                }, function(error){
                    callback(error);
                });
            }, function(error){
                callback(error);
            });
        }
        ,rename: function(fromPath, toPath, callback){
            var
                tmpFromPath= splitPath(fromPath)
                ,tmpToPath= splitPath(toPath)
                ,fromDirectoryPath= tmpFromPath[0]
                ,fromFileName= tmpFromPath[1]
                ,toDirectoryPath= tmpToPath[0]
                ,toFileName= tmpToPath[1]
            ;

            getFileSystem(function(fs){
                fs.root.getDirectory(fromDirectoryPath, {}, function(directoryEntry){
                    directoryEntry.getFile(fromFileName, {}, function(fileEntry){
                        if(fromFileName !== toFileName && fromDirectoryPath === toDirectoryPath) {
                            // simple renaming
                            fileEntry.moveTo(fromDirectoryPath, toFileName);
                        } else if(fromFileName != toFileName && fromDirectoryPath != toDirectoryPath){
                            // rename and move
                            fileEntry.moveTo(toDirectoryPath, toFileName);
                        } else if(fromDirectoryPath != toDirectoryPath){
                            // simple move
                            fileEntry.moveTo(toDirectoryPath);
                        }

                        callback();
                    }, function(error){
                        callback(error);
                    });
                }, function(error){
                    callback(error);
                });
            });
        }
        ,rmdir: function(path, callback){
            getFileSystem(function(fs){
                fs.root.getDirectory(function(directoryEntry){
                    directoryEntry.removeRecursively(callback, callback);
                });
            });
        }
        ,mkdir: function(path, callback){
            var
                folders= path.split('/')
                ,startDirectory
                ,createDir= function(directoryEntry, directoryName){

                    // if a directory name has been passed, then create it inside the current directory
                    if(directoryName) {
                        directoryEntry.getDirectory(directoryName, { create: true }, function(newDirectoryEntry){
                            // recursively call createDir
                            createDir(newDirectoryEntry, folders.shift());
                        }, function(error){
                            callback(error, null);
                        });
                    } else {
                        // we reached the end of the folders, fire the callback function with the last created directory as argument
                        callback(null, broke.fs.Directory(directoryEntry));
                    }
                }
            ;

            getFileSystem(function(fs){
                createDir(fs.root, folders.shift());
            });
        }
        ,readdir: function(path, callback){
            getFileSystem(function(fs){
                fs.root.getDirectory(function(directoryEntry){
                    var
                        reader= directoryEntry.createReader()
                        ,entries= []
                        ,readEntries= function(){
                            reader.readEntries(function(results){
                                if(results.length) {
                                    entries= entries.concat(Array.prototype.slice.call(results));

                                    readEntries();
                                } else {
                                    callback(null, entries);
                                }
                            });
                        }
                    ;

                    readEntries();
                }, function(error){
                    callback(error, null);
                });
            });
        }

        // declared classes
        ,Directory: null
        ,File: null
        ,FileSystem: null
    };

    Class.create({
        __name__: "broke.fs.File"
        ,__init__: function(path, flags, callback){
            var
                instance= this
                ,mode= flags.charAt(0)
                ,readModeEnabled
                ,writeModeEnabled
                ,seekToEnd
                ,truncateFile
                ,createFile
                ,binaryModeEnabled= (/b/).test(flags)
            ;

            if(mode === 'r'){
                readModeEnabled= true;
                writeModeEnabled= (/[+]/).test(flags);
                seekToEnd= false;
                truncateFile= false;
                createFile= false;
            } else if(mode === 'w'){
                readModeEnabled= (/[+]/).test(flags);
                writeModeEnabled= true;
                seekToEnd= false;
                truncateFile= true;
                createFile= true;
            } else if(mode === 'a'){
                readModeEnabled= (/[+]/).test(flags);
                writeModeEnabled= true;
                seekToEnd= true;
                truncateFile= false;
                createFile= true;
            } else{
                readModeEnabled= false;
                writeModeEnabled= false;
                seekToEnd= false;
                truncateFile= false;
                createFile= false;
                if(callback){
                    // TO DO -- An error object should be passed as the first parameter
                    callback(true, null);
                    return;
                }
            }

            this._offset= 0;
            this._file= null;
            this._writer= null;
            this._binaryMode= binaryModeEnabled;

            getFileSystem(function(fs){
                fs.root.getFile(path, {
                        create: createFile
                    }, function(fileEntry){
                        instance._fileEntry= fileEntry;

                        if(readModeEnabled) {
                            fileEntry.file(function(file){
                                instance._file= file;
                                instance._slice= file.slice || file.webkitSlice;

                                if((!writeModeEnabled) || (writeModeEnabled && instance._writer)){
                                    if(callback){
                                        callback(null, instance);
                                    }
                                }
                            }, function(error){
                                if(callback){
                                    callback(error, null);
                                }
                            });
                        }

                        if(writeModeEnabled) {
                            instance._fileEntry.createWriter(function(fileWriter){
                                instance._writer= fileWriter;

                                if(truncateFile){
                                    instance.truncate(0)
                                }

                                if(seekToEnd){
                                    instance.seek(0, broke.fs.SEEK_END);
                                }

                                if((!readModeEnabled) || (readModeEnabled && instance._file)){
                                    if(callback){
                                        callback(null, instance);
                                    }
                                }
                            }, function(error){
                                if(callback){
                                    callback(error, null);
                                }
                            });
                        }
                    }, function(error){
                        if(callback){
                            callback(error, null);
                        }
                    });
            });
        }
        ,read: function(length, callback){
            var
                instance= this
                ,reader= new FileReader()
                ,endpos= ((length === undefined) || (length === null)) ? this._file.size : (this._offset + length)
                ,blob= this._slice.call(this._file, this._offset, endpos)
            ;

            reader.onload= function(event){
                // The callback is given the three arguments, (err, bytesRead, buffer).
                instance._offset+= event.loaded;

                if(callback){
                    callback(null, event.loaded, event.target.result);
                }
            };

            reader.onerror= function(error){
                if(callback){
                    callback(error, 0, null);
                }
            };

            reader.onabort= reader.onerror;

            if(this._binaryMode){
                // TO DO -- readAsBinaryString, readAsArrayBuffer or readAsDataURL ?
                reader.readAsBinaryString(blob);
            } else{
                reader.readAsText(blob);
            }
        }
        ,write: function(buffer, callback){
            var
                instance= this
                ,builderClass= __global__.BlobBuilder || __global__.WebKitBlobBuilder
                ,builderInstance= new builderClass()
            ;

            this._writer.onwrite= function(event){
                instance._offset+= event.loaded;

                // The callback will be given three arguments (err, written, buffer)
                // where written specifies how many bytes were written into buffer.
                if(callback){
                    callback(null, event.loaded, buffer);
                }
            };

            this._writer.onerror= function(error){
                // The operation may fail after writing some bytes.
                // The offset in the file has to be updated according to the bytes written before the error
                instance._offset+= error.loaded;

                if(callback){
                    callback(error, error.loaded, buffer);
                }
            };

            this._writer.onabort= this._writer.onerror;

            builderInstance.append(buffer);

            this._writer.seek(this._offset);

            if(this._binaryMode){
                // TO DO -- MIME Content-Type ?
                this._writer.write(builderInstance.getBlob());
            } else{
                this._writer.write(builderInstance.getBlob('text/plain'));
            }
        }
        ,truncate: function(len){
            var
                length= ((len !== undefined) && (len !== null)) ? len : this._offset
            ;

            if(this._offset > length){
                this._offset= length;
                this._writer.seek(length);
            }

            this._writer.truncate(length);
        }
        ,tell: function(){
            return this._offset;
        }
        ,seek: function(offset, whence){
            if(whence === broke.fs.SEEK_CUR){
                // Relative to current position
                this._offset+= offset;
            } else if(whence === broke.fs.SEEK_END){
                // Relative to file end
                if(this._writer){
                    this._offset= this._writer.length + offset;
                } else if(this._file){
                    this._offset= this._file.size + offset;
                }
            } else{
                // Absolute indexing
                this._offset= offset;
            }

            return this;
        }
        ,rewind: function(){
            this._offset= 0;
        }
        ,readLine: function(size){}
        ,readLines: function(size){}
    });

    Class.create({
        __name__: "broke.fs.Directory"
        ,__init__: function(directoryEntry){
            this.directoryEntry= directoryEntry;
        }
        ,read: function(){}
    });
})(this);/* 
 * Django template engine based on the porting made by xiaocong.hust and John.Sec.Huang
 * http://code.google.com/p/jtl-javascript-template/
 * MIT Licensed
 * 
 */

(function(context, undefined){
    broke.template= {
        // constants
        TOKEN_TEXT: 0,
        TOKEN_VAR: 1,
        TOKEN_BLOCK: 2,
        TOKEN_COMMENT: 3,
        
        _and: 0,
        _or: 1,
        
        // template syntax constants
        FILTER_SEPARATOR: '|',
        FILTER_ARGUMENT_SEPARATOR: ':',
        VARIABLE_ATTRIBUTE_SEPARATOR: '.',
        BLOCK_TAG_START: '{%',
        BLOCK_TAG_END: '%}',
        VARIABLE_TAG_START: '{{',
        VARIABLE_TAG_END: '}}',
        COMMENT_BLOCK_TAG_START: '{#',
        COMMENT_TAG_END: '#}',
        SINGLE_BRACE_START: '{',
        SINGLE_BRACE_END: '}',
        
        tagList: {},
        filterList: {},
        register: {
            tag: function(tagName, fn) {
                broke.template.tagList[tagName]= fn;
            },
            filter: function(filterName, fn) {
                broke.template.filterList[filterName]= fn;
            }
        }
        ,getVar: function(context, varstr) {
            return builtins.getattr(varstr, context);
        }
    };
    
    Class.create({
        __name__: "broke.template.Template"
        ,__init__: function(tpl){
            this._nodelist = this._compile(tpl);
        }
        ,_compile: function(tpl){
            var tokens,
                tagStr= this._formRegx(),
                tagRe= new RegExp(tagStr, 'g'),
                bits= [],
                originalBits= builtins.bsplit(tpl, tagRe);
            
            builtins.forEach(originalBits, function(){
                if(this != "") {
                    bits.push(this);
                }
            });
            
            // create token
            tokens= builtins.map(bits, function(){
                var tagToken;
                
                if(builtins.startsWith(this, broke.template.BLOCK_TAG_START)) {
                    tagToken= this.slice(broke.template.BLOCK_TAG_START.length, -broke.template.BLOCK_TAG_END.length);
                    return broke.template.Token(broke.template.TOKEN_BLOCK, tagToken);
                }
                else if(builtins.startsWith(this, broke.template.VARIABLE_TAG_START)) {
                    return broke.template.Token(broke.template.TOKEN_VAR, this.slice(broke.template.VARIABLE_TAG_START.length, -broke.template.VARIABLE_TAG_END.length));
                } else {
                    return broke.template.Token(broke.template.TOKEN_TEXT, this);
                }
            });
            
            return (broke.template.Parser(tokens)).parse();
        },
        _formRegx: function(){
            var ret = '';
            
            ret += '(' + builtins.rescape(broke.template.BLOCK_TAG_START) + '.*?' + builtins.rescape(broke.template.BLOCK_TAG_END) +
            '|' + builtins.rescape(broke.template.VARIABLE_TAG_START) + '.*?' + builtins.rescape(broke.template.VARIABLE_TAG_END) + '|$' + ')';
            
            return ret;
        },        
        render: function(context){
            var result= [];
            
            builtins.forEach(this._nodelist, function(){
                if(builtins.typeOf(this) == 'object') {
                    builtins.typeOf(this.render) == 'function' ?
                        (result.push(this.render(context)))
                        :
                        (result.push(this.toString()));
                } else {
                    result.push(this.toString());
                }
            });
            
            return broke.template.defaultFilters.escape(result.join(''));
        }
    });

    broke.template.Template.listRender= function(context, nodelist) {
        var result= [];
        
        builtins.forEach(nodelist, function(){
            result.push(this.render(context));
        });
        
        return result.join('');    
    };
    
    Class.create({
        __parent__: window
        ,__name__: "broke.template.Token"
        ,__init__: function(type, content){
            this.type= type;
            
            if(this.type !== broke.template.TOKEN_TEXT) {
                // remove trailing and leading white spaces
                content= content.replace(/^\s+|\s+$/g, '');
            }
            
            this.content= content;
        },
        tsplit: function(){}
    });
})(this);(function(){
    var
        defaultFilters= {
            add: function(value){
                return value.asInt() + value.asInt();
            },
            addslashes: function(value){
                return value.replace('\\', '\\\\').replace('"', '\\"').replace("'", "\\'");
            },
            capfirst: function(value){
                return value[0].upper() + value.slice(1).toLowerCase();
            },
            center: function(value, args){
                return center(value, args.asInt());
            },
            cut: function(value, args){
                return value.replace(args, '');
            },
            date: function(value, args){
                if(typeOf(value) != 'date') {
                    // assume it's a string with format year-month-day
                    // e.g. 2009-12-31
                    value= new Date(value);
                }

                return value.format(args);
            },
            'default': function(value, args){
                return value == '' ? args : value;
            },
            default_if_null: function(value, args){
                return value === null ? args : value;
            },
            dictsort: function(value){
                // TODO
                return value;
            },
            dictsortreversed: function(value){
                // TODO
                return value;
            },
            divisibleby: function(value, args){
                return value.asInt() && args.asInt();
            },
            escape: function(value){
                var baseEscapes= [
                    ['<', '&lt;'],
                    ['>', '&gt;'],
                    ["'", '&#39;'],
                    ['"', '&quot;'],
                    ['&', '&amp;']
                ];
                builtins.forEach(baseEscapes, function(){
                    var bad= this[0],
                        good= this[1];

                    value.replace(bad, good);
                });

                return value;
            },
            escapejs: function(value){
                var baseJsEscapes= [
                    ['\\', '\x5C'],
                    ['\'', '\x27'],
                    ['"', '\x22'],
                    ['>', '\x3E'],
                    ['<', '\x3C'],
                    ['&', '\x26'],
                    ['=', '\x3D'],
                    ['-', '\x2D'],
                    [';', '\x3B'],
                    ['\u2028', '\u2028'],
                    ['\u2029', '\u2029']
                ];

                builtins.forEach(baseJsEscapes, function(){
                    var bad= this[0],
                        good= this[1];

                    value.replace(bad, good);
                });

                return value;
            },
            filesizeformat: function(bytes){
                var KB= 1024,
                    MB= KB * 1024,
                    GB= MB * 1024;

                bytes= bytes.asInt();

                if(bytes < KB) {
                    return gettext.ngettext("%(size)d byte", "%(size)d bytes", bytes).interpolate({
                        size: bytes
                    });
                }
                if(bytes < MB) {
                    return builtins.interpolate(gettext.gettext('%s KB'), bytes / KB);
                }
                if(bytes < GB) {
                    return builtins.interpolate(gettext.gettext('%s MB'), bytes / MB);
                }
                return builtins.interpolate(gettext.gettext('%s GB'), bytes / GB);
            },
            first: function(list){
                return list[0];
            },
            fix_ampersands: function(value){
                return value.replace('&', '&amp;');
            },
            floatformat: function(value, args){
                value= value.split('.');
                args= value[1][args];
                return value[0] + args;
            },
            force_escape: function(value){
                return this.escape(value);
            },
            get_digit: function(value){
                var start= value * -1,
                    end= start + 1;

                return value.slice(start, end);
            },
            iriencode: function(value){
                // TODO
                return value;
            },
            join: function(list, args){
                return list.join(args);
            },
            last: function(value){
                return value.last();
            },
            length: function(value){
                return value.length;
            },
            length_is: function(value, args){
                return value.length == args.asInt();
            },
            linebreaks: function(value){
                // TODO
                return value;
            },
            linebreaksbr: function(value){
                return value.replace(/\n/g, '<br/>');
            },
            linenumbers: function(value){
                var numLines,
                    //maxWidth,
                    i,
                    result= [];

                value= value.split('\n');
                numLines= value.length;
                //maxWidth= (new String(numLines)).length;

                for(i= 0; i< numLines; i++) {
                    result.push((i+1) + '. ' + value[i]);
                }

                return result.join('');
            },
            ljust: function(value, spaces){
                spaces= spaces.asInt() - value.length;

                if(spaces) {
                    value= value.split('');

                    while(spaces--) {
                        value.push(' ');
                    }
                }

                return value.join('');
            },
            lower: function(value){
                return value.toLowerCase();
            },
            make_list: function(value){
                if(typeOf(value) == "number") {
                    value= new String(value);

                    return builtins.map(value.split(''), function(){
                        return this.asInt();
                    });
                }

                return value.split('');
            },
            phone2numeric: function(value){
                // TODO
                return value;
            },
            pluralize: function(value, suffix){
                var suffixes= suffix.split(','),
                    singularSuffix,
                    pluralSuffix;

                if(suffixes.length > 1) {
                    singularSuffix= suffixes[0];
                    pluralSuffix= suffixes[1];
                } else {
                    pluralSuffix= suffixes[0];
                    singularSuffix= '';
                }

                if(value.length > 1) {
                    return pluralSuffix;
                }
                return singularSuffix;
            },
            pprint: function(value){
                // TODO
                return value;
            },
            random: function(list){
                // TODO
                return list;
            },
            removetags: function(value, tags){
                builtins.forEach(tags.split(' '), function(){
                    value.replace('<' + this + '>', '').replace('</' + this + '>', '');
                });

                return value;
            },
            rjust: function(value, spaces){
                spaces= spaces.asInt() - value.length;

                if(spaces) {
                    while(spaces--) {
                        value += ' ';
                    }
                }

                return value;
            },
            safe: function(value){
                // TODO
                return value;
            },
            safeseq: function(list){
                var _this= this;

                return builtins.map(list, function(){
                    return _this.save(this);
                });
            },
            slice: function(list, args){
                // slice as in javascript notation, not python notation
                // e.g. {{ myList|slice:"0, 3" }}
                args= args.split(',');

                if(args.length > 1) {
                    return list.slice(args[0].asInt(), args[1].asInt());
                }
                return list.slice(args[0].asInt());
            },
            slugify: function(value){
                return builtins.slugify(value);
            },
            stringformat: function(value, args){
                // TODO
                return value;
            },
            striptags: function(value){
                return value.replace(/<[a-zA-Z_]>/g, '').replace(/<\/[a-zA-Z_]>/g, '');
            },
            time: function(value){
                // TODO
                return value;
            },
            timesince: function(value){
                // TODO
                return value;
            },
            timeuntil: function(value){
                // TODO
                return value;
            },
            title: function(value){
                // TODO
                return value.capitalize();
            },
            truncatewords: function(value, numberOfWords){
                return value.split(' ').slice(0, numberOfWords).join('') + '...';
            },
            truncatewords_html: function(value){
                // TODO
                return value;
            },
            unordered_list: function(list){
                var createUl= function(list){
                        var newUl= [];

                        builtins.forEach(list, function(){
                            if(typeOf(this) == "array") {
                                newUl.push('<ul>');
                                newUl.push(createUl(this));
                                newUl.push('</ul>');
                            }
                            newUl.push('<li>');
                            newUl.push(this);
                            newUl.push('</li>');
                        });

                        return newUl.join('');
                    };

                return createUl(list);
            },
            upper: function(value){
                return value.upper();
            },
            urlencode: function(value){
                // TODO
                return value;
            },
            urlize: function(value){
                // TODO
                return value;
            },
            urlizetrunc: function(value){
                // TODO
                return value;
            },
            wordcount: function(value){
                return value.split(' ').length;
            },
            wordwrap: function(value, args){
                // TODO
                return value;
            },
            yesno: function(value, args){
                args= args.split(',');

                var yes= args[0],
                    no= args[1],
                    maybe= args[2] || no;

                if(value === null) {
                    return maybe;
                } else if(value) {
                    return yes;
                }

                return no;
            }
        }
    ;
    
    broke.extend(broke.template, {
        defaultFilters: defaultFilters
    });
    
    // register the default filters
    broke.extend(broke.template, {
        filterList: defaultFilters
    });
})();(function(){
    var
        tpl= broke.template,
        register= tpl.register,
        TemplateSyntaxError= broke.exceptions.TemplateSyntaxError
    ;
    
    register.tag('if', function(parser, token){
        var
            bits = token.content.split(/\s+/)
            ,linkType
            ,nodeListTrue
            ,nodeListFalse
            ,bitstr
            ,boolPairs
        ;
        
        bits.shift();
        
        if(!bits){
            throw TemplateSyntaxError(gettext.gettext('If node need at least one args'));
        }
        
        bitstr= bits.join(' ');
        
        boolPairs= bitstr.split(' or ');
        
        if(boolPairs.length == 1){
            linkType = tpl.IfNode._and;
            boolPairs = bitstr.split(' and ');
        } else {
            linkType = tpl.IfNode._or;
            
            if(bitstr.indexOf(' and ') != -1) {
                throw TemplateSyntaxError(gettext.gettext('If node do not allow mix "and" & "or"'));
            }
        }
        
        nodeListTrue = parser.parse(['else','endif']);
        token= parser.nextToken();
        
        if(token.content.indexOf('else') != -1){
            nodeListFalse = parser.parse('endif');
            parser.deleteFirstToken();
        } else {
            nodeListFalse = [];
        }
        return new tpl.IfNode(linkType, boolPairs, nodeListTrue, nodeListFalse);	
    });
    
    register.tag('ifequal', function(parser, token){
        var
            bits = token.content.split(/\s+/)
            ,nodeListTrue
            ,nodeListFalse
            ,bitstr
            ,boolPairs
        ;
        
        bits.shift();
        
        if(bits.length < 2){
            throw TemplateSyntaxError(gettext.gettext('Ifequal node need at least two args'));
        }
        
        nodeListTrue = parser.parse(['else','endifequal']);
        token= parser.nextToken();
        
        if(token.content.indexOf('else') != -1){
            nodeListFalse = parser.parse('endifequal');
            parser.deleteFirstToken();
        } else {
            nodeListFalse = [];
        }
        
        return new tpl.IfEqualNode(bits, nodeListTrue, nodeListFalse);	
    });
    
    register.tag('comment', function(parser, token){
        parser.skipPast('endcomment');
        return new tpl.CommentNode();
    });
    
    register.tag('for', function(parser, token) {
        var
            bits = token.content.split(/\s+/),
            loopvar= bits[1],
            sequence= bits[3],
            reversed= (bits.length == 5),
            nodeListLoop= parser.parse('endfor')
        ;
        
        if(bits.length == 5 && bits[4] != 'reversed'){
            throw TemplateSyntaxError(gettext.gettext('The 4 args of for tag must be reversed'));
        }
        if(!builtins.has([4, 5], bits.length)) {
            throw TemplateSyntaxError(gettext.gettext('The for tag should have 4 or 5 args'));
        }
        if(bits[2] != 'in'){
            throw TemplateSyntaxError(gettext.gettext('The 2nd args of for tag must be "in"'));
        }
        
        parser.deleteFirstToken();
        return new tpl.ForNode(loopvar,sequence,reversed,nodeListLoop);
    });
    
    register.tag('url', function(parser, token) {
        var
            bits = token.content.split(/\s+/)
            ,viewName= bits[1]
            ,args= bits[2].split(',')
            ,asVar
        ;
        
        if(bits.length == 5){
            if(bits[3] != 'as') {
                throw TemplateSyntaxError(gettext.gettext('The 3 args of for tag must be "as"'));
            }
            asVar= bits[3];
        }
        
        return new tpl.UrlNode(viewName, args, asVar);
    });
})();(function(context, undefined){
	var Template= broke.template.Template;
	
	broke.extend(broke.template, {
		loader: {
			renderToString: function(templateName, context){
				var i,
					loader,
					template;
				
				for(i= 0; i< broke.conf.settings.TEMPLATE_LOADERS.length; i++) {
					loader= broke.conf.settings.TEMPLATE_LOADERS[i];
					
					if(builtins.typeOf(loader) == "string") {
						loader= builtins.getattr(loader);
					}
					
					if((template= loader.loadTemplate(templateName))) {
						break;
					}
				};
				
				if(template) {
					return Template(template).render(context);
				}
				
				// no template found
				return '';
			}
		}
	});
})(this);(function(context, undefined){
	var
        templatesCache= {}
		,settings= broke.conf.settings
    ;
	
	broke.extend(broke.template, {
		loaders: {
			apps: {
				loadTemplate: function(templateName){
					var template,
						len= settings.INSTALLED_APPS.length,
						result,
						app;
					
					// loops through all the apps
					while(len--) {
						app= settings.INSTALLED_APPS[len];
						
						if(app) {
							// check if the template exists inside this project's templates
							if(app.templates !== undefined && templateName in app.templates) {
								return app.templates[templateName];
							}
						}
					}
					
					// no template found
					return template;
				}
			}
			,remote: {
				loadTemplate: function(templateName){
					var template,
						url,
						templatePath,
						len= settings.TEMPLATE_PATHS.length;
					
					// not sure about that...
					while(len--) {
						templatePath= settings.TEMPLATE_PATHS;
						
						url= templatePath + '/' + templateName;
						
						if(url in templatesCache) {
							return templatesCache[url];
						}
						
						$.ajax({
							async: false,
							url: url,
							success: function(responseText){
								template= responseText;
								
								// cache the response
								templatesCache[url]= template;
							},
							error: function(error){
								// TODO
							}
						});
					}
					
					return template;
				}
			}
		}
	});
})(this);(function(){
    var
        tpl= broke.template
        ,Template= tpl.Template
        ,TemplateSyntaxError= broke.exceptions.TemplateSyntaxError
        ,settings= broke.conf.settings
    ;
    
    Class.create({
        __name__: "broke.template.VarNode"
        ,__init__: function(varstr){
            var
                args= varstr.split(tpl.FILTER_SEPARATOR)
            ;
            
            this.varstr=  args[0];
            this.filters= args.slice(1);
            this.content= null;
        }
        ,applyFilters: function(){
            var
                _this= this
            ;
            
            builtins.forEach(this.filters, function(){
                // split arguments to pass to the filter, if any
                var args= this.split(tpl.FILTER_ARGUMENT_SEPARATOR)[1] || null;
                
                if(!(this in tpl.filterList)) {
                    // filter not found, fail silently...
                    broke.log('Filter not found, fail silently...');
                    return;
                }
                
                _this.content= tpl.filterList[this](_this.content, args);
            });
            
            return this;
        }
        ,render: function(context){
            var
                content= builtins.getattr(this.varstr, context, "")
            ;
            
            if(builtins.typeOf(content) == "function") {
                content= content();
            }
            
            this.content= content;
            
            if(this.filters) {
                this.applyFilters();
            }
            
            return this.content;
        }
    });
    
    Class.create({
        __name__: "broke.template.TextNode"
        ,__init__: function(str){
            this.str= str;
        }
        ,render: function(){
            return this.str;
        }
    });
    
    Class.create({
        __name__: "broke.template.CommentNode"
        ,__init__: function(str){
            this.str= str;
        }
        ,render: function(context){
            return '';
        }
    });
    
    Class.create({
        __name__: "broke.template.IfNode"
        ,__init__: function(linkType, boolPairs, nodeListTrue, nodeListFalse){
            this.linkType = linkType;
            this.boolPairs = boolPairs;
            this.nodeListTrue = nodeListTrue;
            this.nodeListFalse = nodeListFalse;
        }
        ,render: function(context){
            var
                flag
            ;
            
            if(this.linkType == tpl._and) {
                flag = true;
                
                if(this.mapBoolpair(false, context)) {
                    flag=false;
                }
            } else {
                flag = false;
                
                if(this.mapBoolpair(true, context)) {
                    flag=true;
                }
            }
            
            return flag ? Template.listRender(context, this.nodeListTrue) : Template.listRender(context, this.nodeListFalse);
        }
        ,mapBoolpair: function(tc, context){
            var
                tmpbp = ''
                ,bp = this.boolPairs
                ,i
                ,ilen
            ;
            
            for(i= 0, ilen= bp.length; i< ilen; i++) {
                tmpbp = bp[i].split(' ');
                
                if(tmpbp.length== 2 && tmpbp[0] == 'not') {
                    //if(tc != !!tpl.getVar(context, tmpbp[1])) {
                    if(tc != tpl.getVar(context, tmpbp[1])) {
                        return true;
                    }
                } else {
                    //if(tc == !!tpl.getVar(context, tmpbp[0])) {
                    if(tc == tpl.getVar(context, tmpbp[0])) {
                        return true;
                    }
                }
            }
            return false;
        }
    });
    
    Class.create({
        __name__: "broke.template.IfEqualNode"
        ,__init__: function(vars, nodeListTrue, nodeListFalse){
            this.vars= vars;
            this.nodeListTrue = nodeListTrue;
            this.nodeListFalse = nodeListFalse;
        }
        ,render: function(context){
            var
                flag= true
                ,len= this.vars.length - 1
                ,currentVar
                ,previousVar= tpl.getVar(context, this.vars.slice(-1)[0])
            ;
            
            while(len--) {
                currentVar= tpl.getVar(context, this.vars[len]);
                
                if(previousVar != currentVar) {
                    flag= false;
                }
                
                previousVar= currentVar;
            }
            
            return flag ? Template.listRender(context, this.nodeListTrue) : Template.listRender(context, this.nodeListFalse);
        }
    });
    
    Class.create({
        __name__: "broke.template.ForNode"
        ,__init__: function(loopvar, sequence, reversed, nodeListLoop){
            this.loopvar= loopvar;
            this.sequence= sequence.split('.');
            this.reversed= reversed;
            this.nodeListLoop= nodeListLoop;
        }
        ,render: function(context){
            var
                ret = []
                ,parentloop
                ,items = context
                ,k
                ,i
                ,klen
                ,ilen
            ;
            
            if(context.forloop) {
                parentloop= context.forloop;
            }
            for(k= 0, klen= this.sequence.length; k< klen; k++) {
                items= items[this.sequence[k]];
            }
            
            if(!(items instanceof Array)){
                throw  TemplateSyntaxError(gettext.gettext('values is not a array'));
            }
            
            if(this.reversed){
                items = items.reverse();
            }
            
            for(i= 0, ilen= items.length; i< ilen; i++){
                context.forloop= {
                    //shortcuts for current loop iteration number
                    'counter0': i,
                    'counter': i + 1,
                    //reverse counter iteration numbers
                    'revcounter': ilen - i,
                    'revcounter0': ilen - i - 1,
                    //boolean values designating first and last times through loop
                    'first': (i == 0),
                    'last': (i == (ilen - 1)),
                    'parentloop': parentloop
                };
                
                context[this.loopvar] = items[i];
                ret.push(Template.listRender(context, this.nodeListLoop));
            }
            
            context.forloop = undefined;
            return ret.join('');
        }
    });
    
    Class.create({
        __name__: "broke.template.UrlNode"
        ,__init__: function(viewName, args, asVar){
                this.viewName= viewName;
                this.args= args;
                this.asVar= asVar;
        }
        ,render: function(context){
            var
                reverse= broke.urlResolvers.reverse
                ,args= []
                ,projectName
            ;
            
            builtins.forEach(this.args, function(){
                var thisVar= builtins.getattr(this, context);
                
                if(thisVar === undefined) {
                    thisVar= this.asInt();
                    
                    if(typeOf(thisVar) == "NaN") {
                        thisVar = this;
                    }
                }
                
                args.push(thisVar);
            });
            
            try {
                // named url ?
                url= reverse(this.viewName, args);
                
            } catch(e){
                if(e.name == "NoReverseMatch") {
                    // nope, then it's a path to a view
                    
                    projectName= settings.SETTINGS_MODULE.split('.')[0];
                    url= reverse(projectName + this.viewName, args);
                }
            }
            
            if(this.asVar) {
                context[this.asVar]= url;
                return ''
            }
            return url;
        }
    });
})();(function(){
    var
        tpl= broke.template
        ,TemplateSyntaxError= broke.exceptions.TemplateSyntaxError
    ;
    
    Class.create({
        __parent__: window
        ,__name__: "broke.template.Parser"
        ,__init__: function(tokens){
            this.tokens= tokens;
        },
        parse: function(parseUntil){
            var
                nodelist = []
                ,token = null
                ,tagFuncName = null
                ,tagFunc = null
            ;
            
            if(!parseUntil) {
                parseUntil = [];
            }
            if(!(parseUntil instanceof Array)) {
                parseUntil= [parseUntil];
            }
            
            while(this.tokens.length){
                token= this.tokens.shift();
                
                if(token.type == tpl.TOKEN_TEXT){
                    nodelist.push(new tpl.TextNode(token.content));
                }
                else if(token.type == tpl.TOKEN_VAR){
                    nodelist.push(new tpl.VarNode(token.content));
                }
                else if(token.type == tpl.TOKEN_BLOCK) {
                    if(builtins.has(parseUntil, token.content)) {
                        this.prependToken(token);
                        return nodelist;
                    }
                    
                    tagFuncName= token.content.split(/\s+/)[0];
                    
                    if(!tagFuncName) {
                        throw TemplateSyntaxError(gettext.gettext('Empty Tag'));
                    }
                    tagFunc = tpl.tagList[tagFuncName];
                    
                    if(!tagFunc) {
                        throw TemplateSyntaxError(gettext.gettext('Unknow Tag'));
                    }
                    nodelist.push(tagFunc(this,token));
                }
            }
            return nodelist;
        },
        skipPast: function(endtag){
            var
                token = null
            ;
            
            while(this.tokens.length){
                token = this.tokens.shift();
                
                if(token.type == tpl.TOKEN_BLOCK && token.content == endtag){
                    return;
                }
            }
            throw TemplateSyntaxError(gettext.gettext('Not Closed Tag'));
        },
        prependToken: function(token){
            this.tokens.unshift(token);
        },
        nextToken: function(){
            return this.tokens.shift();
        },
        deleteFirstToken: function(){
            this.tokens.shift();
            return true;
        }
    });
})();;(function(undefined){
    
	broke.extend(broke.utils, {
        functional: {
            lazy: function(fn, context){
                // a much simpler version of the lazy function loader
                // which works with strings only

                // a context needs to be supplied in order to execute the
                // function in the right context
                // defaults to the window object
                context= context || window;

                return function(){
                    var args= Array.prototype.slice.call(arguments);

                    // returns an object which override the toString method
                    // to return whatever function has been supplied
                    // within the right context, given the supplied the arguments
                    return {
                        toString: function(){
                            return fn.apply(context, args);
                        }
                    };
                };
            }
        }
	});
    
})();;(function(undefined){
    
	broke.extend(broke.utils, {
        translation: {
            getLanguageFiles: function(){
                var
                    settings= broke.conf.settings
                    ,languageCode= settings.LANGUAGE_CODE
                    ,localePath= builtins.interpolate('/locale/%s/LC_MESSAGES/broke.po', languageCode)
                    ,localePaths= [
                        settings.BASE_URL + '/conf'
                    ]
                ;

                // projects' locale paths
                localePaths.populate(settings.LOCALE_PATHS);

                builtins.forEach(localePaths, function(){
                    gettext.init({
                        url: this + localePath
                    });
                });

                return;
            }
            ,setLanguage: function(){
                // 1. look in the url
                var queryString= broke.urlResolvers.parseQueryString(location.href.split('?')[1]),
                    cookie= $.cookie(settings.LANGUAGE_COOKIE_NAME),
                    langCodeFromCookie;

                // check query string
                if('language' in queryString) {
                    settings.LANGUAGE_CODE= queryString.language;

                    // set cookie language
                    $.cookie(settings.LANGUAGE_COOKIE_NAME, queryString.language, {
                        expires: 30,
                        domain: location.host,
                        path: '/'
                    });
                } else {
                    // 2. check cookie
                    langCodeFromCookie= $.cookie(settings.LANGUAGE_COOKIE_NAME);

                    settings.LANGUAGE_CODE= langCodeFromCookie || settings.LANGUAGE_CODE;
                }
            }
            ,gettext: function(){}
        }
	});
    
})();;(function(context, undefined){
	broke.views= {
        defaults: {
            setLanguage: function(request){
                var next= request.REQUEST['next'] || null,
                    response= {},
                    settings= broke.conf.settings,
                    langCode,
                    checkForLanguage;

                if(!next) {
                    next= request.META['HTTP_REFERER'];
                }
                if(!next) {
                    next= '';
                }

                langCode= request.REQUEST['language'] || null;

    //			if(langCode && checkForLanguage(langCode)) {
                if(true) {
                    if('session' in request) {
                        // still not sure how to handle this
                        // TODO
                        request.session.brokeLanguage= langCode;
                    } else if('cookie' in request) {
                        // still not sure how to handle this
                        // TODO
                        //request.cookie= [settings.LANGUAGE_COOKIE_NAME, langCode];
                    } else {
                        location.href= location.href.split('#')[0].split('?')[0] + '?language=' + langCode;
                    }
                }

                //broke.events.request(next);
                return {};
            },
            pageNotFound: function(request){
                // no matching url found, fail silently...
                broke.log(gettext.gettext("No matching url found, fail silently..."));
            }
        }
    };
})(this);;(function(context, undefined){
    var
        settings= broke.conf.settings
        ,applyContextProcessors= function(response){
            builtins.forEach(settings.CONTEXT_PROCESSORS, function(){
                var contextProcessor= builtins.getattr(this);
                
                broke.extend(response.context, contextProcessor(response));
            });
            
            return response.context;
        }
    ;
    
    broke.shortcuts= {
        node: {
            create: function(response){
                /* response= {
                 *     template: compulsory template
                 *     context: template's context
                 *     method: after|before|append|prepend|wrap. it defaults to 'append'
                 *     htmlNode: node or string to search the node,
                 *         to which append the newly created node.
                 *         it defaults to 'body'
                 *     emptyHtmlNodeFirst: whether or not to empty the htmlNode
                 *     additionalProperties: additional properties to append to the
                 *         newly created htmlNode
                 *     callback: a function that gets applied to the newly created htmlNode
                 * }
                 *
                 */
                var
                    allowedMethods= ['after', 'before', 'append', 'prepend', 'wrap']
                    ,context= applyContextProcessors(response)
                    ,renderedTemplate= broke.template.loader.renderToString(response.template, context)
                    ,newElement= broke.DOM.m.createFromString(renderedTemplate)
                ;

                // default arguments
                response= broke.extend({
                    method: 'append'
                    ,htmlNode: 'body'
                    ,emptyHtmlNodeFirst: false
                }, response);
                
                if(!builtins.has(allowedMethods, response.method)) {
                    throw broke.exceptions.NotImplementedError(builtins.interpolate(gettext.gettext("The selected template's method (%s) is not implemented. Options are: after, before, append, prepend, wrap"), response.method));
                }

                if(response.emptyHtmlNodeFirst) {
                    broke.DOM.html(response.htmlNode, '');
                }
                
                // append support only, for now
                broke.DOM.m.append(newElement, response.htmlNode);
                
                response.element= newElement;

                if(settings.EVENT_TRIGGERING_METHOD == 'elements') {
                    broke.bindEvents(newElement);
                }
                
                return response;
            }
            ,replace: function(response){
                /*
                 * Renders the template and then replace the element with the
                 * rendered template
                 * response= {
                 *     template: compulsory template
                 *     context: template's context
                 *     htmlNode: node or string to search the node,
                 *         with which replace the newly created node
                 *     additionalProperties: additional properties to append to the
                 *         newly created htmlNode
                 *     callback: a function that gets applied to the newly created htmlNode
                 * }
                 *
                 */
                var
                    context= applyContextProcessors(response)
                    ,renderedTemplate= broke.template.loader.renderToString(response.template, context)
                    ,newElement= broke.DOM.m.createFromString(renderedTemplate)
                ;
                
                // replace
                broke.DOM.m.replace(response.htmlNode, newElement);
                
                response.element= newElement;

                if(settings.EVENT_TRIGGERING_METHOD == 'elements') {
                    broke.bindEvents(newElement);
                }
                
                return response;
            }
            ,update: function(response){
                /*
                 response= {
                 *     object: object with which update the html node
                 *     htmlNode: node or string to search the node to update
                 *     attribute: rel|class
                 *     childrenOnly: whether you want to search direct descendant only
                 *         for optimizations purpose or all the descendants
                 *     additionalProperties: additional properties to append to the
                 *         every single updated node
                 *     callback: a function that gets applied to the newly created htmlNode
                 * }
                 *
                 * This method expect the html node to have children with 
                 * the rel or class attribute corresponding to fields of the object
                 *
                 * i.e.
                 *     object's fields: {
                 *         title: 'New title',
                 *         description: 'New description',
                 *     }
                 *     html node: 
                 *     <ul>
                 *         <li rel="title">My title</li>
                 *         <li rel="description">My description</li>
                 *     </ul>
                 *	
                 * would become:
                 *
                 *     html node: <ul>
                 *         <li rel="title">New title</li>
                 *         <li rel="description">New description</li>
                 *     </ul>
                 *
                 * WARNING: quite resource heavy on big html nodes
                 * TODO: optimize
                 *	
                 */
                var
                    acceptedAttributes= ['class', 'rel']
                    ,searchFor
                ;
                
                // default arguments
                response= broke.extend({
                    attribute: 'rel',
                    childrenOnly: true
                }, response);
                
                searchFor= response.childrenOnly ? '> *' : '*';
                
                if(!builtins.has(acceptedAttributes, response.attribute)) {
                    throw broke.exceptions.NotImplementedError(builtins.interpolate(gettext.gettext("You can not use %s's attribute. Options are: class, rel"), response.attribute));
                }

                builtins.forEach(broke.DOM.querySelector(searchFor, response.htmlNode), function(){
                    var
                        attr= broke.DOM.attr
                        ,key
                    ;
                    
                    for(key in response.object.fields) {
                        
                        if(response.object.fields.hasOwnProperty(key) && attr(this, response.attribute) !== undefined) {
                            
                            if(attr(this, response.attribute).contains(key)) {
                                // update the node
                                broke.DOM.html(this, response.object.fields[key]);
                            }
                        }
                    }
                });
                
                response.element= response.htmlNode;

                return true;
            }
        }
    };
})(this);